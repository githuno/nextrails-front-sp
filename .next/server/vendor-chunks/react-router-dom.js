"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-router-dom";
exports.ids = ["vendor-chunks/react-router-dom"];
exports.modules = {

/***/ "(ssr)/./node_modules/react-router-dom/dist/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/react-router-dom/dist/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AbortedDeferredError: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.AbortedDeferredError),\n/* harmony export */   Await: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.Await),\n/* harmony export */   BrowserRouter: () => (/* binding */ BrowserRouter),\n/* harmony export */   Form: () => (/* binding */ Form),\n/* harmony export */   HashRouter: () => (/* binding */ HashRouter),\n/* harmony export */   Link: () => (/* binding */ Link),\n/* harmony export */   MemoryRouter: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.MemoryRouter),\n/* harmony export */   NavLink: () => (/* binding */ NavLink),\n/* harmony export */   Navigate: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.Navigate),\n/* harmony export */   NavigationType: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.Action),\n/* harmony export */   Outlet: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.Outlet),\n/* harmony export */   Route: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.Route),\n/* harmony export */   Router: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.Router),\n/* harmony export */   RouterProvider: () => (/* binding */ RouterProvider),\n/* harmony export */   Routes: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.Routes),\n/* harmony export */   ScrollRestoration: () => (/* binding */ ScrollRestoration),\n/* harmony export */   UNSAFE_DataRouterContext: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.UNSAFE_DataRouterContext),\n/* harmony export */   UNSAFE_DataRouterStateContext: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.UNSAFE_DataRouterStateContext),\n/* harmony export */   UNSAFE_FetchersContext: () => (/* binding */ FetchersContext),\n/* harmony export */   UNSAFE_LocationContext: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.UNSAFE_LocationContext),\n/* harmony export */   UNSAFE_NavigationContext: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.UNSAFE_NavigationContext),\n/* harmony export */   UNSAFE_RouteContext: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.UNSAFE_RouteContext),\n/* harmony export */   UNSAFE_ViewTransitionContext: () => (/* binding */ ViewTransitionContext),\n/* harmony export */   UNSAFE_useRouteId: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.UNSAFE_useRouteId),\n/* harmony export */   UNSAFE_useScrollRestoration: () => (/* binding */ useScrollRestoration),\n/* harmony export */   createBrowserRouter: () => (/* binding */ createBrowserRouter),\n/* harmony export */   createHashRouter: () => (/* binding */ createHashRouter),\n/* harmony export */   createMemoryRouter: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.createMemoryRouter),\n/* harmony export */   createPath: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.createPath),\n/* harmony export */   createRoutesFromChildren: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.createRoutesFromChildren),\n/* harmony export */   createRoutesFromElements: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.createRoutesFromElements),\n/* harmony export */   createSearchParams: () => (/* binding */ createSearchParams),\n/* harmony export */   defer: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.defer),\n/* harmony export */   generatePath: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.generatePath),\n/* harmony export */   isRouteErrorResponse: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.isRouteErrorResponse),\n/* harmony export */   json: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.json),\n/* harmony export */   matchPath: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.matchPath),\n/* harmony export */   matchRoutes: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.matchRoutes),\n/* harmony export */   parsePath: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.parsePath),\n/* harmony export */   redirect: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.redirect),\n/* harmony export */   redirectDocument: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.redirectDocument),\n/* harmony export */   renderMatches: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.renderMatches),\n/* harmony export */   resolvePath: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.resolvePath),\n/* harmony export */   unstable_HistoryRouter: () => (/* binding */ HistoryRouter),\n/* harmony export */   unstable_usePrompt: () => (/* binding */ usePrompt),\n/* harmony export */   unstable_useViewTransitionState: () => (/* binding */ useViewTransitionState),\n/* harmony export */   useActionData: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.useActionData),\n/* harmony export */   useAsyncError: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.useAsyncError),\n/* harmony export */   useAsyncValue: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.useAsyncValue),\n/* harmony export */   useBeforeUnload: () => (/* binding */ useBeforeUnload),\n/* harmony export */   useBlocker: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.useBlocker),\n/* harmony export */   useFetcher: () => (/* binding */ useFetcher),\n/* harmony export */   useFetchers: () => (/* binding */ useFetchers),\n/* harmony export */   useFormAction: () => (/* binding */ useFormAction),\n/* harmony export */   useHref: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.useHref),\n/* harmony export */   useInRouterContext: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.useInRouterContext),\n/* harmony export */   useLinkClickHandler: () => (/* binding */ useLinkClickHandler),\n/* harmony export */   useLoaderData: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.useLoaderData),\n/* harmony export */   useLocation: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.useLocation),\n/* harmony export */   useMatch: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.useMatch),\n/* harmony export */   useMatches: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.useMatches),\n/* harmony export */   useNavigate: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.useNavigate),\n/* harmony export */   useNavigation: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.useNavigation),\n/* harmony export */   useNavigationType: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.useNavigationType),\n/* harmony export */   useOutlet: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.useOutlet),\n/* harmony export */   useOutletContext: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.useOutletContext),\n/* harmony export */   useParams: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.useParams),\n/* harmony export */   useResolvedPath: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.useResolvedPath),\n/* harmony export */   useRevalidator: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.useRevalidator),\n/* harmony export */   useRouteError: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.useRouteError),\n/* harmony export */   useRouteLoaderData: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.useRouteLoaderData),\n/* harmony export */   useRoutes: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.useRoutes),\n/* harmony export */   useSearchParams: () => (/* binding */ useSearchParams),\n/* harmony export */   useSubmit: () => (/* binding */ useSubmit)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-dom */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-dom.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react_dom__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var react_router__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react-router */ \"(ssr)/./node_modules/react-router/dist/index.js\");\n/* harmony import */ var react_router__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @remix-run/router */ \"(ssr)/./node_modules/@remix-run/router/dist/router.js\");\n/**\n * React Router DOM v6.20.0\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */ \n\n\n\n\nfunction _extends() {\n    _extends = Object.assign ? Object.assign.bind() : function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n}\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n    if (source == null) return {};\n    var target = {};\n    var sourceKeys = Object.keys(source);\n    var key, i;\n    for(i = 0; i < sourceKeys.length; i++){\n        key = sourceKeys[i];\n        if (excluded.indexOf(key) >= 0) continue;\n        target[key] = source[key];\n    }\n    return target;\n}\nconst defaultMethod = \"get\";\nconst defaultEncType = \"application/x-www-form-urlencoded\";\nfunction isHtmlElement(object) {\n    return object != null && typeof object.tagName === \"string\";\n}\nfunction isButtonElement(object) {\n    return isHtmlElement(object) && object.tagName.toLowerCase() === \"button\";\n}\nfunction isFormElement(object) {\n    return isHtmlElement(object) && object.tagName.toLowerCase() === \"form\";\n}\nfunction isInputElement(object) {\n    return isHtmlElement(object) && object.tagName.toLowerCase() === \"input\";\n}\nfunction isModifiedEvent(event) {\n    return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);\n}\nfunction shouldProcessLinkClick(event, target) {\n    return event.button === 0 && // Ignore everything but left clicks\n    (!target || target === \"_self\") && // Let browser handle \"target=_blank\" etc.\n    !isModifiedEvent(event) // Ignore clicks with modifier keys\n    ;\n}\n/**\n * Creates a URLSearchParams object using the given initializer.\n *\n * This is identical to `new URLSearchParams(init)` except it also\n * supports arrays as values in the object form of the initializer\n * instead of just strings. This is convenient when you need multiple\n * values for a given key, but don't want to use an array initializer.\n *\n * For example, instead of:\n *\n *   let searchParams = new URLSearchParams([\n *     ['sort', 'name'],\n *     ['sort', 'price']\n *   ]);\n *\n * you can do:\n *\n *   let searchParams = createSearchParams({\n *     sort: ['name', 'price']\n *   });\n */ function createSearchParams(init) {\n    if (init === void 0) {\n        init = \"\";\n    }\n    return new URLSearchParams(typeof init === \"string\" || Array.isArray(init) || init instanceof URLSearchParams ? init : Object.keys(init).reduce((memo, key)=>{\n        let value = init[key];\n        return memo.concat(Array.isArray(value) ? value.map((v)=>[\n                key,\n                v\n            ]) : [\n            [\n                key,\n                value\n            ]\n        ]);\n    }, []));\n}\nfunction getSearchParamsForLocation(locationSearch, defaultSearchParams) {\n    let searchParams = createSearchParams(locationSearch);\n    if (defaultSearchParams) {\n        // Use `defaultSearchParams.forEach(...)` here instead of iterating of\n        // `defaultSearchParams.keys()` to work-around a bug in Firefox related to\n        // web extensions. Relevant Bugzilla tickets:\n        // https://bugzilla.mozilla.org/show_bug.cgi?id=1414602\n        // https://bugzilla.mozilla.org/show_bug.cgi?id=1023984\n        defaultSearchParams.forEach((_, key)=>{\n            if (!searchParams.has(key)) {\n                defaultSearchParams.getAll(key).forEach((value)=>{\n                    searchParams.append(key, value);\n                });\n            }\n        });\n    }\n    return searchParams;\n}\n// One-time check for submitter support\nlet _formDataSupportsSubmitter = null;\nfunction isFormDataSubmitterSupported() {\n    if (_formDataSupportsSubmitter === null) {\n        try {\n            new FormData(document.createElement(\"form\"), // @ts-expect-error if FormData supports the submitter parameter, this will throw\n            0);\n            _formDataSupportsSubmitter = false;\n        } catch (e) {\n            _formDataSupportsSubmitter = true;\n        }\n    }\n    return _formDataSupportsSubmitter;\n}\nconst supportedFormEncTypes = new Set([\n    \"application/x-www-form-urlencoded\",\n    \"multipart/form-data\",\n    \"text/plain\"\n]);\nfunction getFormEncType(encType) {\n    if (encType != null && !supportedFormEncTypes.has(encType)) {\n         true ? (0,react_router__WEBPACK_IMPORTED_MODULE_2__.UNSAFE_warning)(false, '\"' + encType + '\" is not a valid `encType` for `<Form>`/`<fetcher.Form>` ' + ('and will default to \"' + defaultEncType + '\"')) : 0;\n        return null;\n    }\n    return encType;\n}\nfunction getFormSubmissionInfo(target, basename) {\n    let method;\n    let action;\n    let encType;\n    let formData;\n    let body;\n    if (isFormElement(target)) {\n        // When grabbing the action from the element, it will have had the basename\n        // prefixed to ensure non-JS scenarios work, so strip it since we'll\n        // re-prefix in the router\n        let attr = target.getAttribute(\"action\");\n        action = attr ? (0,react_router__WEBPACK_IMPORTED_MODULE_2__.stripBasename)(attr, basename) : null;\n        method = target.getAttribute(\"method\") || defaultMethod;\n        encType = getFormEncType(target.getAttribute(\"enctype\")) || defaultEncType;\n        formData = new FormData(target);\n    } else if (isButtonElement(target) || isInputElement(target) && (target.type === \"submit\" || target.type === \"image\")) {\n        let form = target.form;\n        if (form == null) {\n            throw new Error('Cannot submit a <button> or <input type=\"submit\"> without a <form>');\n        }\n        // <button>/<input type=\"submit\"> may override attributes of <form>\n        // When grabbing the action from the element, it will have had the basename\n        // prefixed to ensure non-JS scenarios work, so strip it since we'll\n        // re-prefix in the router\n        let attr = target.getAttribute(\"formaction\") || form.getAttribute(\"action\");\n        action = attr ? (0,react_router__WEBPACK_IMPORTED_MODULE_2__.stripBasename)(attr, basename) : null;\n        method = target.getAttribute(\"formmethod\") || form.getAttribute(\"method\") || defaultMethod;\n        encType = getFormEncType(target.getAttribute(\"formenctype\")) || getFormEncType(form.getAttribute(\"enctype\")) || defaultEncType;\n        // Build a FormData object populated from a form and submitter\n        formData = new FormData(form, target);\n        // If this browser doesn't support the `FormData(el, submitter)` format,\n        // then tack on the submitter value at the end.  This is a lightweight\n        // solution that is not 100% spec compliant.  For complete support in older\n        // browsers, consider using the `formdata-submitter-polyfill` package\n        if (!isFormDataSubmitterSupported()) {\n            let { name, type, value } = target;\n            if (type === \"image\") {\n                let prefix = name ? name + \".\" : \"\";\n                formData.append(prefix + \"x\", \"0\");\n                formData.append(prefix + \"y\", \"0\");\n            } else if (name) {\n                formData.append(name, value);\n            }\n        }\n    } else if (isHtmlElement(target)) {\n        throw new Error(\"Cannot submit element that is not <form>, <button>, or \" + '<input type=\"submit|image\">');\n    } else {\n        method = defaultMethod;\n        action = null;\n        encType = defaultEncType;\n        body = target;\n    }\n    // Send body for <Form encType=\"text/plain\" so we encode it into text\n    if (formData && encType === \"text/plain\") {\n        body = formData;\n        formData = undefined;\n    }\n    return {\n        action,\n        method: method.toLowerCase(),\n        encType,\n        formData,\n        body\n    };\n}\nconst _excluded = [\n    \"onClick\",\n    \"relative\",\n    \"reloadDocument\",\n    \"replace\",\n    \"state\",\n    \"target\",\n    \"to\",\n    \"preventScrollReset\",\n    \"unstable_viewTransition\"\n], _excluded2 = [\n    \"aria-current\",\n    \"caseSensitive\",\n    \"className\",\n    \"end\",\n    \"style\",\n    \"to\",\n    \"unstable_viewTransition\",\n    \"children\"\n], _excluded3 = [\n    \"fetcherKey\",\n    \"navigate\",\n    \"reloadDocument\",\n    \"replace\",\n    \"state\",\n    \"method\",\n    \"action\",\n    \"onSubmit\",\n    \"relative\",\n    \"preventScrollReset\",\n    \"unstable_viewTransition\"\n];\nfunction createBrowserRouter(routes, opts) {\n    return (0,react_router__WEBPACK_IMPORTED_MODULE_2__.createRouter)({\n        basename: opts == null ? void 0 : opts.basename,\n        future: _extends({}, opts == null ? void 0 : opts.future, {\n            v7_prependBasename: true\n        }),\n        history: (0,react_router__WEBPACK_IMPORTED_MODULE_2__.createBrowserHistory)({\n            window: opts == null ? void 0 : opts.window\n        }),\n        hydrationData: (opts == null ? void 0 : opts.hydrationData) || parseHydrationData(),\n        routes,\n        mapRouteProperties: react_router__WEBPACK_IMPORTED_MODULE_3__.UNSAFE_mapRouteProperties,\n        window: opts == null ? void 0 : opts.window\n    }).initialize();\n}\nfunction createHashRouter(routes, opts) {\n    return (0,react_router__WEBPACK_IMPORTED_MODULE_2__.createRouter)({\n        basename: opts == null ? void 0 : opts.basename,\n        future: _extends({}, opts == null ? void 0 : opts.future, {\n            v7_prependBasename: true\n        }),\n        history: (0,react_router__WEBPACK_IMPORTED_MODULE_2__.createHashHistory)({\n            window: opts == null ? void 0 : opts.window\n        }),\n        hydrationData: (opts == null ? void 0 : opts.hydrationData) || parseHydrationData(),\n        routes,\n        mapRouteProperties: react_router__WEBPACK_IMPORTED_MODULE_3__.UNSAFE_mapRouteProperties,\n        window: opts == null ? void 0 : opts.window\n    }).initialize();\n}\nfunction parseHydrationData() {\n    var _window;\n    let state = (_window = window) == null ? void 0 : _window.__staticRouterHydrationData;\n    if (state && state.errors) {\n        state = _extends({}, state, {\n            errors: deserializeErrors(state.errors)\n        });\n    }\n    return state;\n}\nfunction deserializeErrors(errors) {\n    if (!errors) return null;\n    let entries = Object.entries(errors);\n    let serialized = {};\n    for (let [key, val] of entries){\n        // Hey you!  If you change this, please change the corresponding logic in\n        // serializeErrors in react-router-dom/server.tsx :)\n        if (val && val.__type === \"RouteErrorResponse\") {\n            serialized[key] = new react_router__WEBPACK_IMPORTED_MODULE_2__.UNSAFE_ErrorResponseImpl(val.status, val.statusText, val.data, val.internal === true);\n        } else if (val && val.__type === \"Error\") {\n            // Attempt to reconstruct the right type of Error (i.e., ReferenceError)\n            if (val.__subType) {\n                let ErrorConstructor = window[val.__subType];\n                if (typeof ErrorConstructor === \"function\") {\n                    try {\n                        // @ts-expect-error\n                        let error = new ErrorConstructor(val.message);\n                        // Wipe away the client-side stack trace.  Nothing to fill it in with\n                        // because we don't serialize SSR stack traces for security reasons\n                        error.stack = \"\";\n                        serialized[key] = error;\n                    } catch (e) {\n                    // no-op - fall through and create a normal Error\n                    }\n                }\n            }\n            if (serialized[key] == null) {\n                let error = new Error(val.message);\n                // Wipe away the client-side stack trace.  Nothing to fill it in with\n                // because we don't serialize SSR stack traces for security reasons\n                error.stack = \"\";\n                serialized[key] = error;\n            }\n        } else {\n            serialized[key] = val;\n        }\n    }\n    return serialized;\n}\nconst ViewTransitionContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext({\n    isTransitioning: false\n});\nif (true) {\n    ViewTransitionContext.displayName = \"ViewTransition\";\n}\nconst FetchersContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(new Map());\nif (true) {\n    FetchersContext.displayName = \"Fetchers\";\n}\n//#endregion\n////////////////////////////////////////////////////////////////////////////////\n//#region Components\n////////////////////////////////////////////////////////////////////////////////\n/**\n  Webpack + React 17 fails to compile on any of the following because webpack\n  complains that `startTransition` doesn't exist in `React`:\n  * import { startTransition } from \"react\"\n  * import * as React from from \"react\";\n    \"startTransition\" in React ? React.startTransition(() => setState()) : setState()\n  * import * as React from from \"react\";\n    \"startTransition\" in React ? React[\"startTransition\"](() => setState()) : setState()\n\n  Moving it to a constant such as the following solves the Webpack/React 17 issue:\n  * import * as React from from \"react\";\n    const START_TRANSITION = \"startTransition\";\n    START_TRANSITION in React ? React[START_TRANSITION](() => setState()) : setState()\n\n  However, that introduces webpack/terser minification issues in production builds\n  in React 18 where minification/obfuscation ends up removing the call of\n  React.startTransition entirely from the first half of the ternary.  Grabbing\n  this exported reference once up front resolves that issue.\n\n  See https://github.com/remix-run/react-router/issues/10579\n*/ const START_TRANSITION = \"startTransition\";\nconst startTransitionImpl = react__WEBPACK_IMPORTED_MODULE_0__[START_TRANSITION];\nconst FLUSH_SYNC = \"flushSync\";\nconst flushSyncImpl = react_dom__WEBPACK_IMPORTED_MODULE_1__[FLUSH_SYNC];\nfunction startTransitionSafe(cb) {\n    if (startTransitionImpl) {\n        startTransitionImpl(cb);\n    } else {\n        cb();\n    }\n}\nfunction flushSyncSafe(cb) {\n    if (flushSyncImpl) {\n        flushSyncImpl(cb);\n    } else {\n        cb();\n    }\n}\nclass Deferred {\n    constructor(){\n        this.status = \"pending\";\n        this.promise = new Promise((resolve, reject)=>{\n            this.resolve = (value)=>{\n                if (this.status === \"pending\") {\n                    this.status = \"resolved\";\n                    resolve(value);\n                }\n            };\n            this.reject = (reason)=>{\n                if (this.status === \"pending\") {\n                    this.status = \"rejected\";\n                    reject(reason);\n                }\n            };\n        });\n    }\n}\n/**\n * Given a Remix Router instance, render the appropriate UI\n */ function RouterProvider(_ref) {\n    let { fallbackElement, router, future } = _ref;\n    let [state, setStateImpl] = react__WEBPACK_IMPORTED_MODULE_0__.useState(router.state);\n    let [pendingState, setPendingState] = react__WEBPACK_IMPORTED_MODULE_0__.useState();\n    let [vtContext, setVtContext] = react__WEBPACK_IMPORTED_MODULE_0__.useState({\n        isTransitioning: false\n    });\n    let [renderDfd, setRenderDfd] = react__WEBPACK_IMPORTED_MODULE_0__.useState();\n    let [transition, setTransition] = react__WEBPACK_IMPORTED_MODULE_0__.useState();\n    let [interruption, setInterruption] = react__WEBPACK_IMPORTED_MODULE_0__.useState();\n    let fetcherData = react__WEBPACK_IMPORTED_MODULE_0__.useRef(new Map());\n    let { v7_startTransition } = future || {};\n    let optInStartTransition = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((cb)=>{\n        if (v7_startTransition) {\n            startTransitionSafe(cb);\n        } else {\n            cb();\n        }\n    }, [\n        v7_startTransition\n    ]);\n    let setState = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((newState, _ref2)=>{\n        let { deletedFetchers, unstable_flushSync: flushSync, unstable_viewTransitionOpts: viewTransitionOpts } = _ref2;\n        deletedFetchers.forEach((key)=>fetcherData.current.delete(key));\n        newState.fetchers.forEach((fetcher, key)=>{\n            if (fetcher.data !== undefined) {\n                fetcherData.current.set(key, fetcher.data);\n            }\n        });\n        let isViewTransitionUnavailable = router.window == null || typeof router.window.document.startViewTransition !== \"function\";\n        // If this isn't a view transition or it's not available in this browser,\n        // just update and be done with it\n        if (!viewTransitionOpts || isViewTransitionUnavailable) {\n            if (flushSync) {\n                flushSyncSafe(()=>setStateImpl(newState));\n            } else {\n                optInStartTransition(()=>setStateImpl(newState));\n            }\n            return;\n        }\n        // flushSync + startViewTransition\n        if (flushSync) {\n            // Flush through the context to mark DOM elements as transition=ing\n            flushSyncSafe(()=>{\n                // Cancel any pending transitions\n                if (transition) {\n                    renderDfd && renderDfd.resolve();\n                    transition.skipTransition();\n                }\n                setVtContext({\n                    isTransitioning: true,\n                    flushSync: true,\n                    currentLocation: viewTransitionOpts.currentLocation,\n                    nextLocation: viewTransitionOpts.nextLocation\n                });\n            });\n            // Update the DOM\n            let t = router.window.document.startViewTransition(()=>{\n                flushSyncSafe(()=>setStateImpl(newState));\n            });\n            // Clean up after the animation completes\n            t.finished.finally(()=>{\n                flushSyncSafe(()=>{\n                    setRenderDfd(undefined);\n                    setTransition(undefined);\n                    setPendingState(undefined);\n                    setVtContext({\n                        isTransitioning: false\n                    });\n                });\n            });\n            flushSyncSafe(()=>setTransition(t));\n            return;\n        }\n        // startTransition + startViewTransition\n        if (transition) {\n            // Interrupting an in-progress transition, cancel and let everything flush\n            // out, and then kick off a new transition from the interruption state\n            renderDfd && renderDfd.resolve();\n            transition.skipTransition();\n            setInterruption({\n                state: newState,\n                currentLocation: viewTransitionOpts.currentLocation,\n                nextLocation: viewTransitionOpts.nextLocation\n            });\n        } else {\n            // Completed navigation update with opted-in view transitions, let 'er rip\n            setPendingState(newState);\n            setVtContext({\n                isTransitioning: true,\n                flushSync: false,\n                currentLocation: viewTransitionOpts.currentLocation,\n                nextLocation: viewTransitionOpts.nextLocation\n            });\n        }\n    }, [\n        router.window,\n        transition,\n        renderDfd,\n        fetcherData,\n        optInStartTransition\n    ]);\n    // Need to use a layout effect here so we are subscribed early enough to\n    // pick up on any render-driven redirects/navigations (useEffect/<Navigate>)\n    react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(()=>router.subscribe(setState), [\n        router,\n        setState\n    ]);\n    // When we start a view transition, create a Deferred we can use for the\n    // eventual \"completed\" render\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (vtContext.isTransitioning && !vtContext.flushSync) {\n            setRenderDfd(new Deferred());\n        }\n    }, [\n        vtContext\n    ]);\n    // Once the deferred is created, kick off startViewTransition() to update the\n    // DOM and then wait on the Deferred to resolve (indicating the DOM update has\n    // happened)\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (renderDfd && pendingState && router.window) {\n            let newState = pendingState;\n            let renderPromise = renderDfd.promise;\n            let transition = router.window.document.startViewTransition(async ()=>{\n                optInStartTransition(()=>setStateImpl(newState));\n                await renderPromise;\n            });\n            transition.finished.finally(()=>{\n                setRenderDfd(undefined);\n                setTransition(undefined);\n                setPendingState(undefined);\n                setVtContext({\n                    isTransitioning: false\n                });\n            });\n            setTransition(transition);\n        }\n    }, [\n        optInStartTransition,\n        pendingState,\n        renderDfd,\n        router.window\n    ]);\n    // When the new location finally renders and is committed to the DOM, this\n    // effect will run to resolve the transition\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (renderDfd && pendingState && state.location.key === pendingState.location.key) {\n            renderDfd.resolve();\n        }\n    }, [\n        renderDfd,\n        transition,\n        state.location,\n        pendingState\n    ]);\n    // If we get interrupted with a new navigation during a transition, we skip\n    // the active transition, let it cleanup, then kick it off again here\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (!vtContext.isTransitioning && interruption) {\n            setPendingState(interruption.state);\n            setVtContext({\n                isTransitioning: true,\n                flushSync: false,\n                currentLocation: interruption.currentLocation,\n                nextLocation: interruption.nextLocation\n            });\n            setInterruption(undefined);\n        }\n    }, [\n        vtContext.isTransitioning,\n        interruption\n    ]);\n    let navigator = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>{\n        return {\n            createHref: router.createHref,\n            encodeLocation: router.encodeLocation,\n            go: (n)=>router.navigate(n),\n            push: (to, state, opts)=>router.navigate(to, {\n                    state,\n                    preventScrollReset: opts == null ? void 0 : opts.preventScrollReset\n                }),\n            replace: (to, state, opts)=>router.navigate(to, {\n                    replace: true,\n                    state,\n                    preventScrollReset: opts == null ? void 0 : opts.preventScrollReset\n                })\n        };\n    }, [\n        router\n    ]);\n    let basename = router.basename || \"/\";\n    let dataRouterContext = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>({\n            router,\n            navigator,\n            static: false,\n            basename\n        }), [\n        router,\n        navigator,\n        basename\n    ]);\n    // The fragment and {null} here are important!  We need them to keep React 18's\n    // useId happy when we are server-rendering since we may have a <script> here\n    // containing the hydrated server-side staticContext (from StaticRouterProvider).\n    // useId relies on the component tree structure to generate deterministic id's\n    // so we need to ensure it remains the same on the client even though\n    // we don't need the <script> tag\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_router__WEBPACK_IMPORTED_MODULE_3__.UNSAFE_DataRouterContext.Provider, {\n        value: dataRouterContext\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_router__WEBPACK_IMPORTED_MODULE_3__.UNSAFE_DataRouterStateContext.Provider, {\n        value: state\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(FetchersContext.Provider, {\n        value: fetcherData.current\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(ViewTransitionContext.Provider, {\n        value: vtContext\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_router__WEBPACK_IMPORTED_MODULE_3__.Router, {\n        basename: basename,\n        location: state.location,\n        navigationType: state.historyAction,\n        navigator: navigator\n    }, state.initialized ? /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(DataRoutes, {\n        routes: router.routes,\n        state: state\n    }) : fallbackElement))))), null);\n}\nfunction DataRoutes(_ref3) {\n    let { routes, state } = _ref3;\n    return (0,react_router__WEBPACK_IMPORTED_MODULE_3__.UNSAFE_useRoutesImpl)(routes, undefined, state);\n}\n/**\n * A `<Router>` for use in web browsers. Provides the cleanest URLs.\n */ function BrowserRouter(_ref4) {\n    let { basename, children, future, window: window1 } = _ref4;\n    let historyRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef();\n    if (historyRef.current == null) {\n        historyRef.current = (0,react_router__WEBPACK_IMPORTED_MODULE_2__.createBrowserHistory)({\n            window: window1,\n            v5Compat: true\n        });\n    }\n    let history = historyRef.current;\n    let [state, setStateImpl] = react__WEBPACK_IMPORTED_MODULE_0__.useState({\n        action: history.action,\n        location: history.location\n    });\n    let { v7_startTransition } = future || {};\n    let setState = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((newState)=>{\n        v7_startTransition && startTransitionImpl ? startTransitionImpl(()=>setStateImpl(newState)) : setStateImpl(newState);\n    }, [\n        setStateImpl,\n        v7_startTransition\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(()=>history.listen(setState), [\n        history,\n        setState\n    ]);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_router__WEBPACK_IMPORTED_MODULE_3__.Router, {\n        basename: basename,\n        children: children,\n        location: state.location,\n        navigationType: state.action,\n        navigator: history\n    });\n}\n/**\n * A `<Router>` for use in web browsers. Stores the location in the hash\n * portion of the URL so it is not sent to the server.\n */ function HashRouter(_ref5) {\n    let { basename, children, future, window: window1 } = _ref5;\n    let historyRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef();\n    if (historyRef.current == null) {\n        historyRef.current = (0,react_router__WEBPACK_IMPORTED_MODULE_2__.createHashHistory)({\n            window: window1,\n            v5Compat: true\n        });\n    }\n    let history = historyRef.current;\n    let [state, setStateImpl] = react__WEBPACK_IMPORTED_MODULE_0__.useState({\n        action: history.action,\n        location: history.location\n    });\n    let { v7_startTransition } = future || {};\n    let setState = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((newState)=>{\n        v7_startTransition && startTransitionImpl ? startTransitionImpl(()=>setStateImpl(newState)) : setStateImpl(newState);\n    }, [\n        setStateImpl,\n        v7_startTransition\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(()=>history.listen(setState), [\n        history,\n        setState\n    ]);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_router__WEBPACK_IMPORTED_MODULE_3__.Router, {\n        basename: basename,\n        children: children,\n        location: state.location,\n        navigationType: state.action,\n        navigator: history\n    });\n}\n/**\n * A `<Router>` that accepts a pre-instantiated history object. It's important\n * to note that using your own history object is highly discouraged and may add\n * two versions of the history library to your bundles unless you use the same\n * version of the history library that React Router uses internally.\n */ function HistoryRouter(_ref6) {\n    let { basename, children, future, history } = _ref6;\n    let [state, setStateImpl] = react__WEBPACK_IMPORTED_MODULE_0__.useState({\n        action: history.action,\n        location: history.location\n    });\n    let { v7_startTransition } = future || {};\n    let setState = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((newState)=>{\n        v7_startTransition && startTransitionImpl ? startTransitionImpl(()=>setStateImpl(newState)) : setStateImpl(newState);\n    }, [\n        setStateImpl,\n        v7_startTransition\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(()=>history.listen(setState), [\n        history,\n        setState\n    ]);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_router__WEBPACK_IMPORTED_MODULE_3__.Router, {\n        basename: basename,\n        children: children,\n        location: state.location,\n        navigationType: state.action,\n        navigator: history\n    });\n}\nif (true) {\n    HistoryRouter.displayName = \"unstable_HistoryRouter\";\n}\nconst isBrowser =  false && 0;\nconst ABSOLUTE_URL_REGEX = /^(?:[a-z][a-z0-9+.-]*:|\\/\\/)/i;\n/**\n * The public API for rendering a history-aware `<a>`.\n */ const Link = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function LinkWithRef(_ref7, ref) {\n    let { onClick, relative, reloadDocument, replace, state, target, to, preventScrollReset, unstable_viewTransition } = _ref7, rest = _objectWithoutPropertiesLoose(_ref7, _excluded);\n    let { basename } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(react_router__WEBPACK_IMPORTED_MODULE_3__.UNSAFE_NavigationContext);\n    // Rendered into <a href> for absolute URLs\n    let absoluteHref;\n    let isExternal = false;\n    if (typeof to === \"string\" && ABSOLUTE_URL_REGEX.test(to)) {\n        // Render the absolute href server- and client-side\n        absoluteHref = to;\n        // Only check for external origins client-side\n        if (isBrowser) {\n            try {\n                let currentUrl = new URL(window.location.href);\n                let targetUrl = to.startsWith(\"//\") ? new URL(currentUrl.protocol + to) : new URL(to);\n                let path = (0,react_router__WEBPACK_IMPORTED_MODULE_2__.stripBasename)(targetUrl.pathname, basename);\n                if (targetUrl.origin === currentUrl.origin && path != null) {\n                    // Strip the protocol/origin/basename for same-origin absolute URLs\n                    to = path + targetUrl.search + targetUrl.hash;\n                } else {\n                    isExternal = true;\n                }\n            } catch (e) {\n                // We can't do external URL detection without a valid URL\n                 true ? (0,react_router__WEBPACK_IMPORTED_MODULE_2__.UNSAFE_warning)(false, '<Link to=\"' + to + '\"> contains an invalid URL which will probably break ' + \"when clicked - please update to a valid URL path.\") : 0;\n            }\n        }\n    }\n    // Rendered into <a href> for relative URLs\n    let href = (0,react_router__WEBPACK_IMPORTED_MODULE_3__.useHref)(to, {\n        relative\n    });\n    let internalOnClick = useLinkClickHandler(to, {\n        replace,\n        state,\n        target,\n        preventScrollReset,\n        relative,\n        unstable_viewTransition\n    });\n    function handleClick(event) {\n        if (onClick) onClick(event);\n        if (!event.defaultPrevented) {\n            internalOnClick(event);\n        }\n    }\n    return(/*#__PURE__*/ // eslint-disable-next-line jsx-a11y/anchor-has-content\n    react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"a\", _extends({}, rest, {\n        href: absoluteHref || href,\n        onClick: isExternal || reloadDocument ? onClick : handleClick,\n        ref: ref,\n        target: target\n    })));\n});\nif (true) {\n    Link.displayName = \"Link\";\n}\n/**\n * A `<Link>` wrapper that knows if it's \"active\" or not.\n */ const NavLink = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function NavLinkWithRef(_ref8, ref) {\n    let { \"aria-current\": ariaCurrentProp = \"page\", caseSensitive = false, className: classNameProp = \"\", end = false, style: styleProp, to, unstable_viewTransition, children } = _ref8, rest = _objectWithoutPropertiesLoose(_ref8, _excluded2);\n    let path = (0,react_router__WEBPACK_IMPORTED_MODULE_3__.useResolvedPath)(to, {\n        relative: rest.relative\n    });\n    let location = (0,react_router__WEBPACK_IMPORTED_MODULE_3__.useLocation)();\n    let routerState = react__WEBPACK_IMPORTED_MODULE_0__.useContext(react_router__WEBPACK_IMPORTED_MODULE_3__.UNSAFE_DataRouterStateContext);\n    let { navigator } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(react_router__WEBPACK_IMPORTED_MODULE_3__.UNSAFE_NavigationContext);\n    let isTransitioning = routerState != null && // Conditional usage is OK here because the usage of a data router is static\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    useViewTransitionState(path) && unstable_viewTransition === true;\n    let toPathname = navigator.encodeLocation ? navigator.encodeLocation(path).pathname : path.pathname;\n    let locationPathname = location.pathname;\n    let nextLocationPathname = routerState && routerState.navigation && routerState.navigation.location ? routerState.navigation.location.pathname : null;\n    if (!caseSensitive) {\n        locationPathname = locationPathname.toLowerCase();\n        nextLocationPathname = nextLocationPathname ? nextLocationPathname.toLowerCase() : null;\n        toPathname = toPathname.toLowerCase();\n    }\n    // If the `to` has a trailing slash, look at that exact spot.  Otherwise,\n    // we're looking for a slash _after_ what's in `to`.  For example:\n    //\n    // <NavLink to=\"/users\"> and <NavLink to=\"/users/\">\n    // both want to look for a / at index 6 to match URL `/users/matt`\n    const endSlashPosition = toPathname !== \"/\" && toPathname.endsWith(\"/\") ? toPathname.length - 1 : toPathname.length;\n    let isActive = locationPathname === toPathname || !end && locationPathname.startsWith(toPathname) && locationPathname.charAt(endSlashPosition) === \"/\";\n    let isPending = nextLocationPathname != null && (nextLocationPathname === toPathname || !end && nextLocationPathname.startsWith(toPathname) && nextLocationPathname.charAt(toPathname.length) === \"/\");\n    let renderProps = {\n        isActive,\n        isPending,\n        isTransitioning\n    };\n    let ariaCurrent = isActive ? ariaCurrentProp : undefined;\n    let className;\n    if (typeof classNameProp === \"function\") {\n        className = classNameProp(renderProps);\n    } else {\n        // If the className prop is not a function, we use a default `active`\n        // class for <NavLink />s that are active. In v5 `active` was the default\n        // value for `activeClassName`, but we are removing that API and can still\n        // use the old default behavior for a cleaner upgrade path and keep the\n        // simple styling rules working as they currently do.\n        className = [\n            classNameProp,\n            isActive ? \"active\" : null,\n            isPending ? \"pending\" : null,\n            isTransitioning ? \"transitioning\" : null\n        ].filter(Boolean).join(\" \");\n    }\n    let style = typeof styleProp === \"function\" ? styleProp(renderProps) : styleProp;\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Link, _extends({}, rest, {\n        \"aria-current\": ariaCurrent,\n        className: className,\n        ref: ref,\n        style: style,\n        to: to,\n        unstable_viewTransition: unstable_viewTransition\n    }), typeof children === \"function\" ? children(renderProps) : children);\n});\nif (true) {\n    NavLink.displayName = \"NavLink\";\n}\n/**\n * A `@remix-run/router`-aware `<form>`. It behaves like a normal form except\n * that the interaction with the server is with `fetch` instead of new document\n * requests, allowing components to add nicer UX to the page as the form is\n * submitted and returns with data.\n */ const Form = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef((_ref9, forwardedRef)=>{\n    let { fetcherKey, navigate, reloadDocument, replace, state, method = defaultMethod, action, onSubmit, relative, preventScrollReset, unstable_viewTransition } = _ref9, props = _objectWithoutPropertiesLoose(_ref9, _excluded3);\n    let submit = useSubmit();\n    let formAction = useFormAction(action, {\n        relative\n    });\n    let formMethod = method.toLowerCase() === \"get\" ? \"get\" : \"post\";\n    let submitHandler = (event)=>{\n        onSubmit && onSubmit(event);\n        if (event.defaultPrevented) return;\n        event.preventDefault();\n        let submitter = event.nativeEvent.submitter;\n        let submitMethod = (submitter == null ? void 0 : submitter.getAttribute(\"formmethod\")) || method;\n        submit(submitter || event.currentTarget, {\n            fetcherKey,\n            method: submitMethod,\n            navigate,\n            replace,\n            state,\n            relative,\n            preventScrollReset,\n            unstable_viewTransition\n        });\n    };\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"form\", _extends({\n        ref: forwardedRef,\n        method: formMethod,\n        action: formAction,\n        onSubmit: reloadDocument ? onSubmit : submitHandler\n    }, props));\n});\nif (true) {\n    Form.displayName = \"Form\";\n}\n/**\n * This component will emulate the browser's scroll restoration on location\n * changes.\n */ function ScrollRestoration(_ref10) {\n    let { getKey, storageKey } = _ref10;\n    useScrollRestoration({\n        getKey,\n        storageKey\n    });\n    return null;\n}\nif (true) {\n    ScrollRestoration.displayName = \"ScrollRestoration\";\n}\n//#endregion\n////////////////////////////////////////////////////////////////////////////////\n//#region Hooks\n////////////////////////////////////////////////////////////////////////////////\nvar DataRouterHook;\n(function(DataRouterHook) {\n    DataRouterHook[\"UseScrollRestoration\"] = \"useScrollRestoration\";\n    DataRouterHook[\"UseSubmit\"] = \"useSubmit\";\n    DataRouterHook[\"UseSubmitFetcher\"] = \"useSubmitFetcher\";\n    DataRouterHook[\"UseFetcher\"] = \"useFetcher\";\n    DataRouterHook[\"useViewTransitionState\"] = \"useViewTransitionState\";\n})(DataRouterHook || (DataRouterHook = {}));\nvar DataRouterStateHook;\n(function(DataRouterStateHook) {\n    DataRouterStateHook[\"UseFetcher\"] = \"useFetcher\";\n    DataRouterStateHook[\"UseFetchers\"] = \"useFetchers\";\n    DataRouterStateHook[\"UseScrollRestoration\"] = \"useScrollRestoration\";\n})(DataRouterStateHook || (DataRouterStateHook = {}));\n// Internal hooks\nfunction getDataRouterConsoleError(hookName) {\n    return hookName + \" must be used within a data router.  See https://reactrouter.com/routers/picking-a-router.\";\n}\nfunction useDataRouterContext(hookName) {\n    let ctx = react__WEBPACK_IMPORTED_MODULE_0__.useContext(react_router__WEBPACK_IMPORTED_MODULE_3__.UNSAFE_DataRouterContext);\n    !ctx ?  true ? (0,react_router__WEBPACK_IMPORTED_MODULE_2__.UNSAFE_invariant)(false, getDataRouterConsoleError(hookName)) : 0 : void 0;\n    return ctx;\n}\nfunction useDataRouterState(hookName) {\n    let state = react__WEBPACK_IMPORTED_MODULE_0__.useContext(react_router__WEBPACK_IMPORTED_MODULE_3__.UNSAFE_DataRouterStateContext);\n    !state ?  true ? (0,react_router__WEBPACK_IMPORTED_MODULE_2__.UNSAFE_invariant)(false, getDataRouterConsoleError(hookName)) : 0 : void 0;\n    return state;\n}\n// External hooks\n/**\n * Handles the click behavior for router `<Link>` components. This is useful if\n * you need to create custom `<Link>` components with the same click behavior we\n * use in our exported `<Link>`.\n */ function useLinkClickHandler(to, _temp) {\n    let { target, replace: replaceProp, state, preventScrollReset, relative, unstable_viewTransition } = _temp === void 0 ? {} : _temp;\n    let navigate = (0,react_router__WEBPACK_IMPORTED_MODULE_3__.useNavigate)();\n    let location = (0,react_router__WEBPACK_IMPORTED_MODULE_3__.useLocation)();\n    let path = (0,react_router__WEBPACK_IMPORTED_MODULE_3__.useResolvedPath)(to, {\n        relative\n    });\n    return react__WEBPACK_IMPORTED_MODULE_0__.useCallback((event)=>{\n        if (shouldProcessLinkClick(event, target)) {\n            event.preventDefault();\n            // If the URL hasn't changed, a regular <a> will do a replace instead of\n            // a push, so do the same here unless the replace prop is explicitly set\n            let replace = replaceProp !== undefined ? replaceProp : (0,react_router__WEBPACK_IMPORTED_MODULE_2__.createPath)(location) === (0,react_router__WEBPACK_IMPORTED_MODULE_2__.createPath)(path);\n            navigate(to, {\n                replace,\n                state,\n                preventScrollReset,\n                relative,\n                unstable_viewTransition\n            });\n        }\n    }, [\n        location,\n        navigate,\n        path,\n        replaceProp,\n        state,\n        target,\n        to,\n        preventScrollReset,\n        relative,\n        unstable_viewTransition\n    ]);\n}\n/**\n * A convenient wrapper for reading and writing search parameters via the\n * URLSearchParams interface.\n */ function useSearchParams(defaultInit) {\n     true ? (0,react_router__WEBPACK_IMPORTED_MODULE_2__.UNSAFE_warning)(typeof URLSearchParams !== \"undefined\", \"You cannot use the `useSearchParams` hook in a browser that does not \" + \"support the URLSearchParams API. If you need to support Internet \" + \"Explorer 11, we recommend you load a polyfill such as \" + \"https://github.com/ungap/url-search-params\\n\\n\" + \"If you're unsure how to load polyfills, we recommend you check out \" + \"https://polyfill.io/v3/ which provides some recommendations about how \" + \"to load polyfills only for users that need them, instead of for every \" + \"user.\") : 0;\n    let defaultSearchParamsRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(createSearchParams(defaultInit));\n    let hasSetSearchParamsRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n    let location = (0,react_router__WEBPACK_IMPORTED_MODULE_3__.useLocation)();\n    let searchParams = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>// Only merge in the defaults if we haven't yet called setSearchParams.\n        // Once we call that we want those to take precedence, otherwise you can't\n        // remove a param with setSearchParams({}) if it has an initial value\n        getSearchParamsForLocation(location.search, hasSetSearchParamsRef.current ? null : defaultSearchParamsRef.current), [\n        location.search\n    ]);\n    let navigate = (0,react_router__WEBPACK_IMPORTED_MODULE_3__.useNavigate)();\n    let setSearchParams = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((nextInit, navigateOptions)=>{\n        const newSearchParams = createSearchParams(typeof nextInit === \"function\" ? nextInit(searchParams) : nextInit);\n        hasSetSearchParamsRef.current = true;\n        navigate(\"?\" + newSearchParams, navigateOptions);\n    }, [\n        navigate,\n        searchParams\n    ]);\n    return [\n        searchParams,\n        setSearchParams\n    ];\n}\nfunction validateClientSideSubmission() {\n    if (typeof document === \"undefined\") {\n        throw new Error(\"You are calling submit during the server render. \" + \"Try calling submit within a `useEffect` or callback instead.\");\n    }\n}\nlet fetcherId = 0;\nlet getUniqueFetcherId = ()=>\"__\" + String(++fetcherId) + \"__\";\n/**\n * Returns a function that may be used to programmatically submit a form (or\n * some arbitrary data) to the server.\n */ function useSubmit() {\n    let { router } = useDataRouterContext(DataRouterHook.UseSubmit);\n    let { basename } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(react_router__WEBPACK_IMPORTED_MODULE_3__.UNSAFE_NavigationContext);\n    let currentRouteId = (0,react_router__WEBPACK_IMPORTED_MODULE_3__.UNSAFE_useRouteId)();\n    return react__WEBPACK_IMPORTED_MODULE_0__.useCallback(function(target, options) {\n        if (options === void 0) {\n            options = {};\n        }\n        validateClientSideSubmission();\n        let { action, method, encType, formData, body } = getFormSubmissionInfo(target, basename);\n        if (options.navigate === false) {\n            let key = options.fetcherKey || getUniqueFetcherId();\n            router.fetch(key, currentRouteId, options.action || action, {\n                preventScrollReset: options.preventScrollReset,\n                formData,\n                body,\n                formMethod: options.method || method,\n                formEncType: options.encType || encType,\n                unstable_flushSync: options.unstable_flushSync\n            });\n        } else {\n            router.navigate(options.action || action, {\n                preventScrollReset: options.preventScrollReset,\n                formData,\n                body,\n                formMethod: options.method || method,\n                formEncType: options.encType || encType,\n                replace: options.replace,\n                state: options.state,\n                fromRouteId: currentRouteId,\n                unstable_flushSync: options.unstable_flushSync,\n                unstable_viewTransition: options.unstable_viewTransition\n            });\n        }\n    }, [\n        router,\n        basename,\n        currentRouteId\n    ]);\n}\n// v7: Eventually we should deprecate this entirely in favor of using the\n// router method directly?\nfunction useFormAction(action, _temp2) {\n    let { relative } = _temp2 === void 0 ? {} : _temp2;\n    let { basename } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(react_router__WEBPACK_IMPORTED_MODULE_3__.UNSAFE_NavigationContext);\n    let routeContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(react_router__WEBPACK_IMPORTED_MODULE_3__.UNSAFE_RouteContext);\n    !routeContext ?  true ? (0,react_router__WEBPACK_IMPORTED_MODULE_2__.UNSAFE_invariant)(false, \"useFormAction must be used inside a RouteContext\") : 0 : void 0;\n    let [match] = routeContext.matches.slice(-1);\n    // Shallow clone path so we can modify it below, otherwise we modify the\n    // object referenced by useMemo inside useResolvedPath\n    let path = _extends({}, (0,react_router__WEBPACK_IMPORTED_MODULE_3__.useResolvedPath)(action ? action : \".\", {\n        relative\n    }));\n    // If no action was specified, browsers will persist current search params\n    // when determining the path, so match that behavior\n    // https://github.com/remix-run/remix/issues/927\n    let location = (0,react_router__WEBPACK_IMPORTED_MODULE_3__.useLocation)();\n    if (action == null) {\n        // Safe to write to this directly here since if action was undefined, we\n        // would have called useResolvedPath(\".\") which will never include a search\n        path.search = location.search;\n        // When grabbing search params from the URL, remove any included ?index param\n        // since it might not apply to our contextual route.  We add it back based\n        // on match.route.index below\n        let params = new URLSearchParams(path.search);\n        if (params.has(\"index\") && params.get(\"index\") === \"\") {\n            params.delete(\"index\");\n            path.search = params.toString() ? \"?\" + params.toString() : \"\";\n        }\n    }\n    if ((!action || action === \".\") && match.route.index) {\n        path.search = path.search ? path.search.replace(/^\\?/, \"?index&\") : \"?index\";\n    }\n    // If we're operating within a basename, prepend it to the pathname prior\n    // to creating the form action.  If this is a root navigation, then just use\n    // the raw basename which allows the basename to have full control over the\n    // presence of a trailing slash on root actions\n    if (basename !== \"/\") {\n        path.pathname = path.pathname === \"/\" ? basename : (0,react_router__WEBPACK_IMPORTED_MODULE_2__.joinPaths)([\n            basename,\n            path.pathname\n        ]);\n    }\n    return (0,react_router__WEBPACK_IMPORTED_MODULE_2__.createPath)(path);\n}\n// TODO: (v7) Change the useFetcher generic default from `any` to `unknown`\n/**\n * Interacts with route loaders and actions without causing a navigation. Great\n * for any interaction that stays on the same page.\n */ function useFetcher(_temp3) {\n    var _route$matches;\n    let { key } = _temp3 === void 0 ? {} : _temp3;\n    let { router } = useDataRouterContext(DataRouterHook.UseFetcher);\n    let state = useDataRouterState(DataRouterStateHook.UseFetcher);\n    let fetcherData = react__WEBPACK_IMPORTED_MODULE_0__.useContext(FetchersContext);\n    let route = react__WEBPACK_IMPORTED_MODULE_0__.useContext(react_router__WEBPACK_IMPORTED_MODULE_3__.UNSAFE_RouteContext);\n    let routeId = (_route$matches = route.matches[route.matches.length - 1]) == null ? void 0 : _route$matches.route.id;\n    !fetcherData ?  true ? (0,react_router__WEBPACK_IMPORTED_MODULE_2__.UNSAFE_invariant)(false, \"useFetcher must be used inside a FetchersContext\") : 0 : void 0;\n    !route ?  true ? (0,react_router__WEBPACK_IMPORTED_MODULE_2__.UNSAFE_invariant)(false, \"useFetcher must be used inside a RouteContext\") : 0 : void 0;\n    !(routeId != null) ?  true ? (0,react_router__WEBPACK_IMPORTED_MODULE_2__.UNSAFE_invariant)(false, 'useFetcher can only be used on routes that contain a unique \"id\"') : 0 : void 0;\n    // Fetcher key handling\n    let [fetcherKey, setFetcherKey] = react__WEBPACK_IMPORTED_MODULE_0__.useState(key || \"\");\n    if (key && key !== fetcherKey) {\n        setFetcherKey(key);\n    } else if (!fetcherKey) {\n        setFetcherKey(getUniqueFetcherId());\n    }\n    // Registration/cleanup\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        router.getFetcher(fetcherKey);\n        return ()=>{\n            // Tell the router we've unmounted - if v7_fetcherPersist is enabled this\n            // will not delete immediately but instead queue up a delete after the\n            // fetcher returns to an `idle` state\n            router.deleteFetcher(fetcherKey);\n        };\n    }, [\n        router,\n        fetcherKey\n    ]);\n    // Fetcher additions\n    let load = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((href, opts)=>{\n        !routeId ?  true ? (0,react_router__WEBPACK_IMPORTED_MODULE_2__.UNSAFE_invariant)(false, \"No routeId available for fetcher.load()\") : 0 : void 0;\n        router.fetch(fetcherKey, routeId, href, opts);\n    }, [\n        fetcherKey,\n        routeId,\n        router\n    ]);\n    let submitImpl = useSubmit();\n    let submit = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((target, opts)=>{\n        submitImpl(target, _extends({}, opts, {\n            navigate: false,\n            fetcherKey\n        }));\n    }, [\n        fetcherKey,\n        submitImpl\n    ]);\n    let FetcherForm = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>{\n        let FetcherForm = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef((props, ref)=>{\n            return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Form, _extends({}, props, {\n                navigate: false,\n                fetcherKey: fetcherKey,\n                ref: ref\n            }));\n        });\n        if (true) {\n            FetcherForm.displayName = \"fetcher.Form\";\n        }\n        return FetcherForm;\n    }, [\n        fetcherKey\n    ]);\n    // Exposed FetcherWithComponents\n    let fetcher = state.fetchers.get(fetcherKey) || react_router__WEBPACK_IMPORTED_MODULE_2__.IDLE_FETCHER;\n    let data = fetcherData.get(fetcherKey);\n    let fetcherWithComponents = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>_extends({\n            Form: FetcherForm,\n            submit,\n            load\n        }, fetcher, {\n            data\n        }), [\n        FetcherForm,\n        submit,\n        load,\n        fetcher,\n        data\n    ]);\n    return fetcherWithComponents;\n}\n/**\n * Provides all fetchers currently on the page. Useful for layouts and parent\n * routes that need to provide pending/optimistic UI regarding the fetch.\n */ function useFetchers() {\n    let state = useDataRouterState(DataRouterStateHook.UseFetchers);\n    return Array.from(state.fetchers.entries()).map((_ref11)=>{\n        let [key, fetcher] = _ref11;\n        return _extends({}, fetcher, {\n            key\n        });\n    });\n}\nconst SCROLL_RESTORATION_STORAGE_KEY = \"react-router-scroll-positions\";\nlet savedScrollPositions = {};\n/**\n * When rendered inside a RouterProvider, will restore scroll positions on navigations\n */ function useScrollRestoration(_temp4) {\n    let { getKey, storageKey } = _temp4 === void 0 ? {} : _temp4;\n    let { router } = useDataRouterContext(DataRouterHook.UseScrollRestoration);\n    let { restoreScrollPosition, preventScrollReset } = useDataRouterState(DataRouterStateHook.UseScrollRestoration);\n    let { basename } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(react_router__WEBPACK_IMPORTED_MODULE_3__.UNSAFE_NavigationContext);\n    let location = (0,react_router__WEBPACK_IMPORTED_MODULE_3__.useLocation)();\n    let matches = (0,react_router__WEBPACK_IMPORTED_MODULE_3__.useMatches)();\n    let navigation = (0,react_router__WEBPACK_IMPORTED_MODULE_3__.useNavigation)();\n    // Trigger manual scroll restoration while we're active\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        window.history.scrollRestoration = \"manual\";\n        return ()=>{\n            window.history.scrollRestoration = \"auto\";\n        };\n    }, []);\n    // Save positions on pagehide\n    usePageHide(react__WEBPACK_IMPORTED_MODULE_0__.useCallback(()=>{\n        if (navigation.state === \"idle\") {\n            let key = (getKey ? getKey(location, matches) : null) || location.key;\n            savedScrollPositions[key] = window.scrollY;\n        }\n        try {\n            sessionStorage.setItem(storageKey || SCROLL_RESTORATION_STORAGE_KEY, JSON.stringify(savedScrollPositions));\n        } catch (error) {\n             true ? (0,react_router__WEBPACK_IMPORTED_MODULE_2__.UNSAFE_warning)(false, \"Failed to save scroll positions in sessionStorage, <ScrollRestoration /> will not work properly (\" + error + \").\") : 0;\n        }\n        window.history.scrollRestoration = \"auto\";\n    }, [\n        storageKey,\n        getKey,\n        navigation.state,\n        location,\n        matches\n    ]));\n    // Read in any saved scroll locations\n    if (typeof document !== \"undefined\") {\n        // eslint-disable-next-line react-hooks/rules-of-hooks\n        react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(()=>{\n            try {\n                let sessionPositions = sessionStorage.getItem(storageKey || SCROLL_RESTORATION_STORAGE_KEY);\n                if (sessionPositions) {\n                    savedScrollPositions = JSON.parse(sessionPositions);\n                }\n            } catch (e) {\n            // no-op, use default empty object\n            }\n        }, [\n            storageKey\n        ]);\n        // Enable scroll restoration in the router\n        // eslint-disable-next-line react-hooks/rules-of-hooks\n        react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(()=>{\n            let getKeyWithoutBasename = getKey && basename !== \"/\" ? (location, matches)=>getKey(_extends({}, location, {\n                    pathname: (0,react_router__WEBPACK_IMPORTED_MODULE_2__.stripBasename)(location.pathname, basename) || location.pathname\n                }), matches) : getKey;\n            let disableScrollRestoration = router == null ? void 0 : router.enableScrollRestoration(savedScrollPositions, ()=>window.scrollY, getKeyWithoutBasename);\n            return ()=>disableScrollRestoration && disableScrollRestoration();\n        }, [\n            router,\n            basename,\n            getKey\n        ]);\n        // Restore scrolling when state.restoreScrollPosition changes\n        // eslint-disable-next-line react-hooks/rules-of-hooks\n        react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(()=>{\n            // Explicit false means don't do anything (used for submissions)\n            if (restoreScrollPosition === false) {\n                return;\n            }\n            // been here before, scroll to it\n            if (typeof restoreScrollPosition === \"number\") {\n                window.scrollTo(0, restoreScrollPosition);\n                return;\n            }\n            // try to scroll to the hash\n            if (location.hash) {\n                let el = document.getElementById(decodeURIComponent(location.hash.slice(1)));\n                if (el) {\n                    el.scrollIntoView();\n                    return;\n                }\n            }\n            // Don't reset if this navigation opted out\n            if (preventScrollReset === true) {\n                return;\n            }\n            // otherwise go to the top on new locations\n            window.scrollTo(0, 0);\n        }, [\n            location,\n            restoreScrollPosition,\n            preventScrollReset\n        ]);\n    }\n}\n/**\n * Setup a callback to be fired on the window's `beforeunload` event. This is\n * useful for saving some data to `window.localStorage` just before the page\n * refreshes.\n *\n * Note: The `callback` argument should be a function created with\n * `React.useCallback()`.\n */ function useBeforeUnload(callback, options) {\n    let { capture } = options || {};\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        let opts = capture != null ? {\n            capture\n        } : undefined;\n        window.addEventListener(\"beforeunload\", callback, opts);\n        return ()=>{\n            window.removeEventListener(\"beforeunload\", callback, opts);\n        };\n    }, [\n        callback,\n        capture\n    ]);\n}\n/**\n * Setup a callback to be fired on the window's `pagehide` event. This is\n * useful for saving some data to `window.localStorage` just before the page\n * refreshes.  This event is better supported than beforeunload across browsers.\n *\n * Note: The `callback` argument should be a function created with\n * `React.useCallback()`.\n */ function usePageHide(callback, options) {\n    let { capture } = options || {};\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        let opts = capture != null ? {\n            capture\n        } : undefined;\n        window.addEventListener(\"pagehide\", callback, opts);\n        return ()=>{\n            window.removeEventListener(\"pagehide\", callback, opts);\n        };\n    }, [\n        callback,\n        capture\n    ]);\n}\n/**\n * Wrapper around useBlocker to show a window.confirm prompt to users instead\n * of building a custom UI with useBlocker.\n *\n * Warning: This has *a lot of rough edges* and behaves very differently (and\n * very incorrectly in some cases) across browsers if user click addition\n * back/forward navigations while the confirm is open.  Use at your own risk.\n */ function usePrompt(_ref12) {\n    let { when, message } = _ref12;\n    let blocker = (0,react_router__WEBPACK_IMPORTED_MODULE_3__.useBlocker)(when);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (blocker.state === \"blocked\") {\n            let proceed = window.confirm(message);\n            if (proceed) {\n                // This timeout is needed to avoid a weird \"race\" on POP navigations\n                // between the `window.history` revert navigation and the result of\n                // `window.confirm`\n                setTimeout(blocker.proceed, 0);\n            } else {\n                blocker.reset();\n            }\n        }\n    }, [\n        blocker,\n        message\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (blocker.state === \"blocked\" && !when) {\n            blocker.reset();\n        }\n    }, [\n        blocker,\n        when\n    ]);\n}\n/**\n * Return a boolean indicating if there is an active view transition to the\n * given href.  You can use this value to render CSS classes or viewTransitionName\n * styles onto your elements\n *\n * @param href The destination href\n * @param [opts.relative] Relative routing type (\"route\" | \"path\")\n */ function useViewTransitionState(to, opts) {\n    if (opts === void 0) {\n        opts = {};\n    }\n    let vtContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(ViewTransitionContext);\n    !(vtContext != null) ?  true ? (0,react_router__WEBPACK_IMPORTED_MODULE_2__.UNSAFE_invariant)(false, \"`unstable_useViewTransitionState` must be used within `react-router-dom`'s `RouterProvider`.  \" + \"Did you accidentally import `RouterProvider` from `react-router`?\") : 0 : void 0;\n    let { basename } = useDataRouterContext(DataRouterHook.useViewTransitionState);\n    let path = (0,react_router__WEBPACK_IMPORTED_MODULE_3__.useResolvedPath)(to, {\n        relative: opts.relative\n    });\n    if (!vtContext.isTransitioning) {\n        return false;\n    }\n    let currentPath = (0,react_router__WEBPACK_IMPORTED_MODULE_2__.stripBasename)(vtContext.currentLocation.pathname, basename) || vtContext.currentLocation.pathname;\n    let nextPath = (0,react_router__WEBPACK_IMPORTED_MODULE_2__.stripBasename)(vtContext.nextLocation.pathname, basename) || vtContext.nextLocation.pathname;\n    // Transition is active if we're going to or coming from the indicated\n    // destination.  This ensures that other PUSH navigations that reverse\n    // an indicated transition apply.  I.e., on the list view you have:\n    //\n    //   <NavLink to=\"/details/1\" unstable_viewTransition>\n    //\n    // If you click the breadcrumb back to the list view:\n    //\n    //   <NavLink to=\"/list\" unstable_viewTransition>\n    //\n    // We should apply the transition because it's indicated as active going\n    // from /list -> /details/1 and therefore should be active on the reverse\n    // (even though this isn't strictly a POP reverse)\n    return (0,react_router__WEBPACK_IMPORTED_MODULE_2__.matchPath)(path.pathname, nextPath) != null || (0,react_router__WEBPACK_IMPORTED_MODULE_2__.matchPath)(path.pathname, currentPath) != null;\n}\n//#endregion\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyLWRvbS9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7Ozs7Ozs7OztDQVNDLEdBQzhCO0FBQ087QUFDbVI7QUFDMGU7QUFDMWxCO0FBRXpNLFNBQVNnRTtJQUNQQSxXQUFXQyxPQUFPQyxNQUFNLEdBQUdELE9BQU9DLE1BQU0sQ0FBQ0MsSUFBSSxLQUFLLFNBQVVDLE1BQU07UUFDaEUsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlDLFVBQVVDLE1BQU0sRUFBRUYsSUFBSztZQUN6QyxJQUFJRyxTQUFTRixTQUFTLENBQUNELEVBQUU7WUFDekIsSUFBSyxJQUFJSSxPQUFPRCxPQUFRO2dCQUN0QixJQUFJUCxPQUFPUyxTQUFTLENBQUNDLGNBQWMsQ0FBQ0MsSUFBSSxDQUFDSixRQUFRQyxNQUFNO29CQUNyREwsTUFBTSxDQUFDSyxJQUFJLEdBQUdELE1BQU0sQ0FBQ0MsSUFBSTtnQkFDM0I7WUFDRjtRQUNGO1FBQ0EsT0FBT0w7SUFDVDtJQUNBLE9BQU9KLFNBQVNhLEtBQUssQ0FBQyxJQUFJLEVBQUVQO0FBQzlCO0FBQ0EsU0FBU1EsOEJBQThCTixNQUFNLEVBQUVPLFFBQVE7SUFDckQsSUFBSVAsVUFBVSxNQUFNLE9BQU8sQ0FBQztJQUM1QixJQUFJSixTQUFTLENBQUM7SUFDZCxJQUFJWSxhQUFhZixPQUFPZ0IsSUFBSSxDQUFDVDtJQUM3QixJQUFJQyxLQUFLSjtJQUNULElBQUtBLElBQUksR0FBR0EsSUFBSVcsV0FBV1QsTUFBTSxFQUFFRixJQUFLO1FBQ3RDSSxNQUFNTyxVQUFVLENBQUNYLEVBQUU7UUFDbkIsSUFBSVUsU0FBU0csT0FBTyxDQUFDVCxRQUFRLEdBQUc7UUFDaENMLE1BQU0sQ0FBQ0ssSUFBSSxHQUFHRCxNQUFNLENBQUND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QSxPQUFPLENBQUM7SUFDVjtJQUNBLElBQUl5RCxZQUFZOU0sNkNBQWdCLENBQUNpTDtJQUNqQyxDQUFFNkIsQ0FBQUEsYUFBYSxJQUFHLElBQUsxQixLQUFxQyxHQUFHdkgsOERBQWdCQSxDQUFDLE9BQU8sbUdBQW1HLHVFQUF1RUEsQ0FBdUIsR0FBRyxLQUFLO0lBQ2hTLElBQUksRUFDRnNFLFFBQVEsRUFDVCxHQUFHbU8scUJBQXFCSixlQUFlckMsc0JBQXNCO0lBQzlELElBQUlwQixPQUFPaFMsNkRBQWVBLENBQUNvUCxJQUFJO1FBQzdCOEIsVUFBVXRJLEtBQUtzSSxRQUFRO0lBQ3pCO0lBQ0EsSUFBSSxDQUFDN0UsVUFBVTNCLGVBQWUsRUFBRTtRQUM5QixPQUFPO0lBQ1Q7SUFDQSxJQUFJeVEsY0FBY3JZLDJEQUFhQSxDQUFDdUosVUFBVTZCLGVBQWUsQ0FBQytELFFBQVEsRUFBRXZLLGFBQWEyRSxVQUFVNkIsZUFBZSxDQUFDK0QsUUFBUTtJQUNuSCxJQUFJbUosV0FBV3RZLDJEQUFhQSxDQUFDdUosVUFBVThCLFlBQVksQ0FBQzhELFFBQVEsRUFBRXZLLGFBQWEyRSxVQUFVOEIsWUFBWSxDQUFDOEQsUUFBUTtJQUMxRyxzRUFBc0U7SUFDdEUsc0VBQXNFO0lBQ3RFLG1FQUFtRTtJQUNuRSxFQUFFO0lBQ0Ysc0RBQXNEO0lBQ3RELEVBQUU7SUFDRixxREFBcUQ7SUFDckQsRUFBRTtJQUNGLGlEQUFpRDtJQUNqRCxFQUFFO0lBQ0Ysd0VBQXdFO0lBQ3hFLHlFQUF5RTtJQUN6RSxrREFBa0Q7SUFDbEQsT0FBT3hRLHVEQUFTQSxDQUFDdVEsS0FBS0MsUUFBUSxFQUFFbUosYUFBYSxRQUFRM1osdURBQVNBLENBQUN1USxLQUFLQyxRQUFRLEVBQUVrSixnQkFBZ0I7QUFDaEc7QUFDQSxZQUFZO0FBRWtoQixDQUM5aEIsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyLWRvbS9kaXN0L2luZGV4LmpzPzAzYTYiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBSZWFjdCBSb3V0ZXIgRE9NIHY2LjIwLjBcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIFJlbWl4IFNvZnR3YXJlIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UubWQgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0ICogYXMgUmVhY3RET00gZnJvbSAncmVhY3QtZG9tJztcbmltcG9ydCB7IFVOU0FGRV9tYXBSb3V0ZVByb3BlcnRpZXMsIFVOU0FGRV9EYXRhUm91dGVyQ29udGV4dCwgVU5TQUZFX0RhdGFSb3V0ZXJTdGF0ZUNvbnRleHQsIFJvdXRlciwgVU5TQUZFX3VzZVJvdXRlc0ltcGwsIFVOU0FGRV9OYXZpZ2F0aW9uQ29udGV4dCwgdXNlSHJlZiwgdXNlUmVzb2x2ZWRQYXRoLCB1c2VMb2NhdGlvbiwgdXNlTmF2aWdhdGUsIGNyZWF0ZVBhdGgsIFVOU0FGRV91c2VSb3V0ZUlkLCBVTlNBRkVfUm91dGVDb250ZXh0LCB1c2VNYXRjaGVzLCB1c2VOYXZpZ2F0aW9uLCB1c2VCbG9ja2VyIH0gZnJvbSAncmVhY3Qtcm91dGVyJztcbmV4cG9ydCB7IEFib3J0ZWREZWZlcnJlZEVycm9yLCBBd2FpdCwgTWVtb3J5Um91dGVyLCBOYXZpZ2F0ZSwgTmF2aWdhdGlvblR5cGUsIE91dGxldCwgUm91dGUsIFJvdXRlciwgUm91dGVzLCBVTlNBRkVfRGF0YVJvdXRlckNvbnRleHQsIFVOU0FGRV9EYXRhUm91dGVyU3RhdGVDb250ZXh0LCBVTlNBRkVfTG9jYXRpb25Db250ZXh0LCBVTlNBRkVfTmF2aWdhdGlvbkNvbnRleHQsIFVOU0FGRV9Sb3V0ZUNvbnRleHQsIFVOU0FGRV91c2VSb3V0ZUlkLCBjcmVhdGVNZW1vcnlSb3V0ZXIsIGNyZWF0ZVBhdGgsIGNyZWF0ZVJvdXRlc0Zyb21DaGlsZHJlbiwgY3JlYXRlUm91dGVzRnJvbUVsZW1lbnRzLCBkZWZlciwgZ2VuZXJhdGVQYXRoLCBpc1JvdXRlRXJyb3JSZXNwb25zZSwganNvbiwgbWF0Y2hQYXRoLCBtYXRjaFJvdXRlcywgcGFyc2VQYXRoLCByZWRpcmVjdCwgcmVkaXJlY3REb2N1bWVudCwgcmVuZGVyTWF0Y2hlcywgcmVzb2x2ZVBhdGgsIHVzZUFjdGlvbkRhdGEsIHVzZUFzeW5jRXJyb3IsIHVzZUFzeW5jVmFsdWUsIHVzZUJsb2NrZXIsIHVzZUhyZWYsIHVzZUluUm91dGVyQ29udGV4dCwgdXNlTG9hZGVyRGF0YSwgdXNlTG9jYXRpb24sIHVzZU1hdGNoLCB1c2VNYXRjaGVzLCB1c2VOYXZpZ2F0ZSwgdXNlTmF2aWdhdGlvbiwgdXNlTmF2aWdhdGlvblR5cGUsIHVzZU91dGxldCwgdXNlT3V0bGV0Q29udGV4dCwgdXNlUGFyYW1zLCB1c2VSZXNvbHZlZFBhdGgsIHVzZVJldmFsaWRhdG9yLCB1c2VSb3V0ZUVycm9yLCB1c2VSb3V0ZUxvYWRlckRhdGEsIHVzZVJvdXRlcyB9IGZyb20gJ3JlYWN0LXJvdXRlcic7XG5pbXBvcnQgeyBzdHJpcEJhc2VuYW1lLCBVTlNBRkVfd2FybmluZywgY3JlYXRlUm91dGVyLCBjcmVhdGVCcm93c2VySGlzdG9yeSwgY3JlYXRlSGFzaEhpc3RvcnksIFVOU0FGRV9FcnJvclJlc3BvbnNlSW1wbCwgVU5TQUZFX2ludmFyaWFudCwgam9pblBhdGhzLCBJRExFX0ZFVENIRVIsIG1hdGNoUGF0aCB9IGZyb20gJ0ByZW1peC1ydW4vcm91dGVyJztcblxuZnVuY3Rpb24gX2V4dGVuZHMoKSB7XG4gIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiA/IE9iamVjdC5hc3NpZ24uYmluZCgpIDogZnVuY3Rpb24gKHRhcmdldCkge1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldO1xuICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfTtcbiAgcmV0dXJuIF9leHRlbmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKSB7XG4gIGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9O1xuICB2YXIgdGFyZ2V0ID0ge307XG4gIHZhciBzb3VyY2VLZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTtcbiAgdmFyIGtleSwgaTtcbiAgZm9yIChpID0gMDsgaSA8IHNvdXJjZUtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBrZXkgPSBzb3VyY2VLZXlzW2ldO1xuICAgIGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7XG4gICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgfVxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5jb25zdCBkZWZhdWx0TWV0aG9kID0gXCJnZXRcIjtcbmNvbnN0IGRlZmF1bHRFbmNUeXBlID0gXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIjtcbmZ1bmN0aW9uIGlzSHRtbEVsZW1lbnQob2JqZWN0KSB7XG4gIHJldHVybiBvYmplY3QgIT0gbnVsbCAmJiB0eXBlb2Ygb2JqZWN0LnRhZ05hbWUgPT09IFwic3RyaW5nXCI7XG59XG5mdW5jdGlvbiBpc0J1dHRvbkVsZW1lbnQob2JqZWN0KSB7XG4gIHJldHVybiBpc0h0bWxFbGVtZW50KG9iamVjdCkgJiYgb2JqZWN0LnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJidXR0b25cIjtcbn1cbmZ1bmN0aW9uIGlzRm9ybUVsZW1lbnQob2JqZWN0KSB7XG4gIHJldHVybiBpc0h0bWxFbGVtZW50KG9iamVjdCkgJiYgb2JqZWN0LnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJmb3JtXCI7XG59XG5mdW5jdGlvbiBpc0lucHV0RWxlbWVudChvYmplY3QpIHtcbiAgcmV0dXJuIGlzSHRtbEVsZW1lbnQob2JqZWN0KSAmJiBvYmplY3QudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcImlucHV0XCI7XG59XG5mdW5jdGlvbiBpc01vZGlmaWVkRXZlbnQoZXZlbnQpIHtcbiAgcmV0dXJuICEhKGV2ZW50Lm1ldGFLZXkgfHwgZXZlbnQuYWx0S2V5IHx8IGV2ZW50LmN0cmxLZXkgfHwgZXZlbnQuc2hpZnRLZXkpO1xufVxuZnVuY3Rpb24gc2hvdWxkUHJvY2Vzc0xpbmtDbGljayhldmVudCwgdGFyZ2V0KSB7XG4gIHJldHVybiBldmVudC5idXR0b24gPT09IDAgJiYgKFxuICAvLyBJZ25vcmUgZXZlcnl0aGluZyBidXQgbGVmdCBjbGlja3NcbiAgIXRhcmdldCB8fCB0YXJnZXQgPT09IFwiX3NlbGZcIikgJiZcbiAgLy8gTGV0IGJyb3dzZXIgaGFuZGxlIFwidGFyZ2V0PV9ibGFua1wiIGV0Yy5cbiAgIWlzTW9kaWZpZWRFdmVudChldmVudCkgLy8gSWdub3JlIGNsaWNrcyB3aXRoIG1vZGlmaWVyIGtleXNcbiAgO1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgVVJMU2VhcmNoUGFyYW1zIG9iamVjdCB1c2luZyB0aGUgZ2l2ZW4gaW5pdGlhbGl6ZXIuXG4gKlxuICogVGhpcyBpcyBpZGVudGljYWwgdG8gYG5ldyBVUkxTZWFyY2hQYXJhbXMoaW5pdClgIGV4Y2VwdCBpdCBhbHNvXG4gKiBzdXBwb3J0cyBhcnJheXMgYXMgdmFsdWVzIGluIHRoZSBvYmplY3QgZm9ybSBvZiB0aGUgaW5pdGlhbGl6ZXJcbiAqIGluc3RlYWQgb2YganVzdCBzdHJpbmdzLiBUaGlzIGlzIGNvbnZlbmllbnQgd2hlbiB5b3UgbmVlZCBtdWx0aXBsZVxuICogdmFsdWVzIGZvciBhIGdpdmVuIGtleSwgYnV0IGRvbid0IHdhbnQgdG8gdXNlIGFuIGFycmF5IGluaXRpYWxpemVyLlxuICpcbiAqIEZvciBleGFtcGxlLCBpbnN0ZWFkIG9mOlxuICpcbiAqICAgbGV0IHNlYXJjaFBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoW1xuICogICAgIFsnc29ydCcsICduYW1lJ10sXG4gKiAgICAgWydzb3J0JywgJ3ByaWNlJ11cbiAqICAgXSk7XG4gKlxuICogeW91IGNhbiBkbzpcbiAqXG4gKiAgIGxldCBzZWFyY2hQYXJhbXMgPSBjcmVhdGVTZWFyY2hQYXJhbXMoe1xuICogICAgIHNvcnQ6IFsnbmFtZScsICdwcmljZSddXG4gKiAgIH0pO1xuICovXG5mdW5jdGlvbiBjcmVhdGVTZWFyY2hQYXJhbXMoaW5pdCkge1xuICBpZiAoaW5pdCA9PT0gdm9pZCAwKSB7XG4gICAgaW5pdCA9IFwiXCI7XG4gIH1cbiAgcmV0dXJuIG5ldyBVUkxTZWFyY2hQYXJhbXModHlwZW9mIGluaXQgPT09IFwic3RyaW5nXCIgfHwgQXJyYXkuaXNBcnJheShpbml0KSB8fCBpbml0IGluc3RhbmNlb2YgVVJMU2VhcmNoUGFyYW1zID8gaW5pdCA6IE9iamVjdC5rZXlzKGluaXQpLnJlZHVjZSgobWVtbywga2V5KSA9PiB7XG4gICAgbGV0IHZhbHVlID0gaW5pdFtrZXldO1xuICAgIHJldHVybiBtZW1vLmNvbmNhdChBcnJheS5pc0FycmF5KHZhbHVlKSA/IHZhbHVlLm1hcCh2ID0+IFtrZXksIHZdKSA6IFtba2V5LCB2YWx1ZV1dKTtcbiAgfSwgW10pKTtcbn1cbmZ1bmN0aW9uIGdldFNlYXJjaFBhcmFtc0ZvckxvY2F0aW9uKGxvY2F0aW9uU2VhcmNoLCBkZWZhdWx0U2VhcmNoUGFyYW1zKSB7XG4gIGxldCBzZWFyY2hQYXJhbXMgPSBjcmVhdGVTZWFyY2hQYXJhbXMobG9jYXRpb25TZWFyY2gpO1xuICBpZiAoZGVmYXVsdFNlYXJjaFBhcmFtcykge1xuICAgIC8vIFVzZSBgZGVmYXVsdFNlYXJjaFBhcmFtcy5mb3JFYWNoKC4uLilgIGhlcmUgaW5zdGVhZCBvZiBpdGVyYXRpbmcgb2ZcbiAgICAvLyBgZGVmYXVsdFNlYXJjaFBhcmFtcy5rZXlzKClgIHRvIHdvcmstYXJvdW5kIGEgYnVnIGluIEZpcmVmb3ggcmVsYXRlZCB0b1xuICAgIC8vIHdlYiBleHRlbnNpb25zLiBSZWxldmFudCBCdWd6aWxsYSB0aWNrZXRzOlxuICAgIC8vIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTE0MTQ2MDJcbiAgICAvLyBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0xMDIzOTg0XG4gICAgZGVmYXVsdFNlYXJjaFBhcmFtcy5mb3JFYWNoKChfLCBrZXkpID0+IHtcbiAgICAgIGlmICghc2VhcmNoUGFyYW1zLmhhcyhrZXkpKSB7XG4gICAgICAgIGRlZmF1bHRTZWFyY2hQYXJhbXMuZ2V0QWxsKGtleSkuZm9yRWFjaCh2YWx1ZSA9PiB7XG4gICAgICAgICAgc2VhcmNoUGFyYW1zLmFwcGVuZChrZXksIHZhbHVlKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHNlYXJjaFBhcmFtcztcbn1cbi8vIE9uZS10aW1lIGNoZWNrIGZvciBzdWJtaXR0ZXIgc3VwcG9ydFxubGV0IF9mb3JtRGF0YVN1cHBvcnRzU3VibWl0dGVyID0gbnVsbDtcbmZ1bmN0aW9uIGlzRm9ybURhdGFTdWJtaXR0ZXJTdXBwb3J0ZWQoKSB7XG4gIGlmIChfZm9ybURhdGFTdXBwb3J0c1N1Ym1pdHRlciA9PT0gbnVsbCkge1xuICAgIHRyeSB7XG4gICAgICBuZXcgRm9ybURhdGEoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImZvcm1cIiksXG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIGlmIEZvcm1EYXRhIHN1cHBvcnRzIHRoZSBzdWJtaXR0ZXIgcGFyYW1ldGVyLCB0aGlzIHdpbGwgdGhyb3dcbiAgICAgIDApO1xuICAgICAgX2Zvcm1EYXRhU3VwcG9ydHNTdWJtaXR0ZXIgPSBmYWxzZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBfZm9ybURhdGFTdXBwb3J0c1N1Ym1pdHRlciA9IHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBfZm9ybURhdGFTdXBwb3J0c1N1Ym1pdHRlcjtcbn1cbmNvbnN0IHN1cHBvcnRlZEZvcm1FbmNUeXBlcyA9IG5ldyBTZXQoW1wiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCIsIFwibXVsdGlwYXJ0L2Zvcm0tZGF0YVwiLCBcInRleHQvcGxhaW5cIl0pO1xuZnVuY3Rpb24gZ2V0Rm9ybUVuY1R5cGUoZW5jVHlwZSkge1xuICBpZiAoZW5jVHlwZSAhPSBudWxsICYmICFzdXBwb3J0ZWRGb3JtRW5jVHlwZXMuaGFzKGVuY1R5cGUpKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gVU5TQUZFX3dhcm5pbmcoZmFsc2UsIFwiXFxcIlwiICsgZW5jVHlwZSArIFwiXFxcIiBpcyBub3QgYSB2YWxpZCBgZW5jVHlwZWAgZm9yIGA8Rm9ybT5gL2A8ZmV0Y2hlci5Gb3JtPmAgXCIgKyAoXCJhbmQgd2lsbCBkZWZhdWx0IHRvIFxcXCJcIiArIGRlZmF1bHRFbmNUeXBlICsgXCJcXFwiXCIpKSA6IHZvaWQgMDtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gZW5jVHlwZTtcbn1cbmZ1bmN0aW9uIGdldEZvcm1TdWJtaXNzaW9uSW5mbyh0YXJnZXQsIGJhc2VuYW1lKSB7XG4gIGxldCBtZXRob2Q7XG4gIGxldCBhY3Rpb247XG4gIGxldCBlbmNUeXBlO1xuICBsZXQgZm9ybURhdGE7XG4gIGxldCBib2R5O1xuICBpZiAoaXNGb3JtRWxlbWVudCh0YXJnZXQpKSB7XG4gICAgLy8gV2hlbiBncmFiYmluZyB0aGUgYWN0aW9uIGZyb20gdGhlIGVsZW1lbnQsIGl0IHdpbGwgaGF2ZSBoYWQgdGhlIGJhc2VuYW1lXG4gICAgLy8gcHJlZml4ZWQgdG8gZW5zdXJlIG5vbi1KUyBzY2VuYXJpb3Mgd29yaywgc28gc3RyaXAgaXQgc2luY2Ugd2UnbGxcbiAgICAvLyByZS1wcmVmaXggaW4gdGhlIHJvdXRlclxuICAgIGxldCBhdHRyID0gdGFyZ2V0LmdldEF0dHJpYnV0ZShcImFjdGlvblwiKTtcbiAgICBhY3Rpb24gPSBhdHRyID8gc3RyaXBCYXNlbmFtZShhdHRyLCBiYXNlbmFtZSkgOiBudWxsO1xuICAgIG1ldGhvZCA9IHRhcmdldC5nZXRBdHRyaWJ1dGUoXCJtZXRob2RcIikgfHwgZGVmYXVsdE1ldGhvZDtcbiAgICBlbmNUeXBlID0gZ2V0Rm9ybUVuY1R5cGUodGFyZ2V0LmdldEF0dHJpYnV0ZShcImVuY3R5cGVcIikpIHx8IGRlZmF1bHRFbmNUeXBlO1xuICAgIGZvcm1EYXRhID0gbmV3IEZvcm1EYXRhKHRhcmdldCk7XG4gIH0gZWxzZSBpZiAoaXNCdXR0b25FbGVtZW50KHRhcmdldCkgfHwgaXNJbnB1dEVsZW1lbnQodGFyZ2V0KSAmJiAodGFyZ2V0LnR5cGUgPT09IFwic3VibWl0XCIgfHwgdGFyZ2V0LnR5cGUgPT09IFwiaW1hZ2VcIikpIHtcbiAgICBsZXQgZm9ybSA9IHRhcmdldC5mb3JtO1xuICAgIGlmIChmb3JtID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBzdWJtaXQgYSA8YnV0dG9uPiBvciA8aW5wdXQgdHlwZT1cXFwic3VibWl0XFxcIj4gd2l0aG91dCBhIDxmb3JtPlwiKTtcbiAgICB9XG4gICAgLy8gPGJ1dHRvbj4vPGlucHV0IHR5cGU9XCJzdWJtaXRcIj4gbWF5IG92ZXJyaWRlIGF0dHJpYnV0ZXMgb2YgPGZvcm0+XG4gICAgLy8gV2hlbiBncmFiYmluZyB0aGUgYWN0aW9uIGZyb20gdGhlIGVsZW1lbnQsIGl0IHdpbGwgaGF2ZSBoYWQgdGhlIGJhc2VuYW1lXG4gICAgLy8gcHJlZml4ZWQgdG8gZW5zdXJlIG5vbi1KUyBzY2VuYXJpb3Mgd29yaywgc28gc3RyaXAgaXQgc2luY2Ugd2UnbGxcbiAgICAvLyByZS1wcmVmaXggaW4gdGhlIHJvdXRlclxuICAgIGxldCBhdHRyID0gdGFyZ2V0LmdldEF0dHJpYnV0ZShcImZvcm1hY3Rpb25cIikgfHwgZm9ybS5nZXRBdHRyaWJ1dGUoXCJhY3Rpb25cIik7XG4gICAgYWN0aW9uID0gYXR0ciA/IHN0cmlwQmFzZW5hbWUoYXR0ciwgYmFzZW5hbWUpIDogbnVsbDtcbiAgICBtZXRob2QgPSB0YXJnZXQuZ2V0QXR0cmlidXRlKFwiZm9ybW1ldGhvZFwiKSB8fCBmb3JtLmdldEF0dHJpYnV0ZShcIm1ldGhvZFwiKSB8fCBkZWZhdWx0TWV0aG9kO1xuICAgIGVuY1R5cGUgPSBnZXRGb3JtRW5jVHlwZSh0YXJnZXQuZ2V0QXR0cmlidXRlKFwiZm9ybWVuY3R5cGVcIikpIHx8IGdldEZvcm1FbmNUeXBlKGZvcm0uZ2V0QXR0cmlidXRlKFwiZW5jdHlwZVwiKSkgfHwgZGVmYXVsdEVuY1R5cGU7XG4gICAgLy8gQnVpbGQgYSBGb3JtRGF0YSBvYmplY3QgcG9wdWxhdGVkIGZyb20gYSBmb3JtIGFuZCBzdWJtaXR0ZXJcbiAgICBmb3JtRGF0YSA9IG5ldyBGb3JtRGF0YShmb3JtLCB0YXJnZXQpO1xuICAgIC8vIElmIHRoaXMgYnJvd3NlciBkb2Vzbid0IHN1cHBvcnQgdGhlIGBGb3JtRGF0YShlbCwgc3VibWl0dGVyKWAgZm9ybWF0LFxuICAgIC8vIHRoZW4gdGFjayBvbiB0aGUgc3VibWl0dGVyIHZhbHVlIGF0IHRoZSBlbmQuICBUaGlzIGlzIGEgbGlnaHR3ZWlnaHRcbiAgICAvLyBzb2x1dGlvbiB0aGF0IGlzIG5vdCAxMDAlIHNwZWMgY29tcGxpYW50LiAgRm9yIGNvbXBsZXRlIHN1cHBvcnQgaW4gb2xkZXJcbiAgICAvLyBicm93c2VycywgY29uc2lkZXIgdXNpbmcgdGhlIGBmb3JtZGF0YS1zdWJtaXR0ZXItcG9seWZpbGxgIHBhY2thZ2VcbiAgICBpZiAoIWlzRm9ybURhdGFTdWJtaXR0ZXJTdXBwb3J0ZWQoKSkge1xuICAgICAgbGV0IHtcbiAgICAgICAgbmFtZSxcbiAgICAgICAgdHlwZSxcbiAgICAgICAgdmFsdWVcbiAgICAgIH0gPSB0YXJnZXQ7XG4gICAgICBpZiAodHlwZSA9PT0gXCJpbWFnZVwiKSB7XG4gICAgICAgIGxldCBwcmVmaXggPSBuYW1lID8gbmFtZSArIFwiLlwiIDogXCJcIjtcbiAgICAgICAgZm9ybURhdGEuYXBwZW5kKHByZWZpeCArIFwieFwiLCBcIjBcIik7XG4gICAgICAgIGZvcm1EYXRhLmFwcGVuZChwcmVmaXggKyBcInlcIiwgXCIwXCIpO1xuICAgICAgfSBlbHNlIGlmIChuYW1lKSB7XG4gICAgICAgIGZvcm1EYXRhLmFwcGVuZChuYW1lLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzSHRtbEVsZW1lbnQodGFyZ2V0KSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBzdWJtaXQgZWxlbWVudCB0aGF0IGlzIG5vdCA8Zm9ybT4sIDxidXR0b24+LCBvciBcIiArIFwiPGlucHV0IHR5cGU9XFxcInN1Ym1pdHxpbWFnZVxcXCI+XCIpO1xuICB9IGVsc2Uge1xuICAgIG1ldGhvZCA9IGRlZmF1bHRNZXRob2Q7XG4gICAgYWN0aW9uID0gbnVsbDtcbiAgICBlbmNUeXBlID0gZGVmYXVsdEVuY1R5cGU7XG4gICAgYm9keSA9IHRhcmdldDtcbiAgfVxuICAvLyBTZW5kIGJvZHkgZm9yIDxGb3JtIGVuY1R5cGU9XCJ0ZXh0L3BsYWluXCIgc28gd2UgZW5jb2RlIGl0IGludG8gdGV4dFxuICBpZiAoZm9ybURhdGEgJiYgZW5jVHlwZSA9PT0gXCJ0ZXh0L3BsYWluXCIpIHtcbiAgICBib2R5ID0gZm9ybURhdGE7XG4gICAgZm9ybURhdGEgPSB1bmRlZmluZWQ7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBhY3Rpb24sXG4gICAgbWV0aG9kOiBtZXRob2QudG9Mb3dlckNhc2UoKSxcbiAgICBlbmNUeXBlLFxuICAgIGZvcm1EYXRhLFxuICAgIGJvZHlcbiAgfTtcbn1cblxuY29uc3QgX2V4Y2x1ZGVkID0gW1wib25DbGlja1wiLCBcInJlbGF0aXZlXCIsIFwicmVsb2FkRG9jdW1lbnRcIiwgXCJyZXBsYWNlXCIsIFwic3RhdGVcIiwgXCJ0YXJnZXRcIiwgXCJ0b1wiLCBcInByZXZlbnRTY3JvbGxSZXNldFwiLCBcInVuc3RhYmxlX3ZpZXdUcmFuc2l0aW9uXCJdLFxuICBfZXhjbHVkZWQyID0gW1wiYXJpYS1jdXJyZW50XCIsIFwiY2FzZVNlbnNpdGl2ZVwiLCBcImNsYXNzTmFtZVwiLCBcImVuZFwiLCBcInN0eWxlXCIsIFwidG9cIiwgXCJ1bnN0YWJsZV92aWV3VHJhbnNpdGlvblwiLCBcImNoaWxkcmVuXCJdLFxuICBfZXhjbHVkZWQzID0gW1wiZmV0Y2hlcktleVwiLCBcIm5hdmlnYXRlXCIsIFwicmVsb2FkRG9jdW1lbnRcIiwgXCJyZXBsYWNlXCIsIFwic3RhdGVcIiwgXCJtZXRob2RcIiwgXCJhY3Rpb25cIiwgXCJvblN1Ym1pdFwiLCBcInJlbGF0aXZlXCIsIFwicHJldmVudFNjcm9sbFJlc2V0XCIsIFwidW5zdGFibGVfdmlld1RyYW5zaXRpb25cIl07XG5mdW5jdGlvbiBjcmVhdGVCcm93c2VyUm91dGVyKHJvdXRlcywgb3B0cykge1xuICByZXR1cm4gY3JlYXRlUm91dGVyKHtcbiAgICBiYXNlbmFtZTogb3B0cyA9PSBudWxsID8gdm9pZCAwIDogb3B0cy5iYXNlbmFtZSxcbiAgICBmdXR1cmU6IF9leHRlbmRzKHt9LCBvcHRzID09IG51bGwgPyB2b2lkIDAgOiBvcHRzLmZ1dHVyZSwge1xuICAgICAgdjdfcHJlcGVuZEJhc2VuYW1lOiB0cnVlXG4gICAgfSksXG4gICAgaGlzdG9yeTogY3JlYXRlQnJvd3Nlckhpc3Rvcnkoe1xuICAgICAgd2luZG93OiBvcHRzID09IG51bGwgPyB2b2lkIDAgOiBvcHRzLndpbmRvd1xuICAgIH0pLFxuICAgIGh5ZHJhdGlvbkRhdGE6IChvcHRzID09IG51bGwgPyB2b2lkIDAgOiBvcHRzLmh5ZHJhdGlvbkRhdGEpIHx8IHBhcnNlSHlkcmF0aW9uRGF0YSgpLFxuICAgIHJvdXRlcyxcbiAgICBtYXBSb3V0ZVByb3BlcnRpZXM6IFVOU0FGRV9tYXBSb3V0ZVByb3BlcnRpZXMsXG4gICAgd2luZG93OiBvcHRzID09IG51bGwgPyB2b2lkIDAgOiBvcHRzLndpbmRvd1xuICB9KS5pbml0aWFsaXplKCk7XG59XG5mdW5jdGlvbiBjcmVhdGVIYXNoUm91dGVyKHJvdXRlcywgb3B0cykge1xuICByZXR1cm4gY3JlYXRlUm91dGVyKHtcbiAgICBiYXNlbmFtZTogb3B0cyA9PSBudWxsID8gdm9pZCAwIDogb3B0cy5iYXNlbmFtZSxcbiAgICBmdXR1cmU6IF9leHRlbmRzKHt9LCBvcHRzID09IG51bGwgPyB2b2lkIDAgOiBvcHRzLmZ1dHVyZSwge1xuICAgICAgdjdfcHJlcGVuZEJhc2VuYW1lOiB0cnVlXG4gICAgfSksXG4gICAgaGlzdG9yeTogY3JlYXRlSGFzaEhpc3Rvcnkoe1xuICAgICAgd2luZG93OiBvcHRzID09IG51bGwgPyB2b2lkIDAgOiBvcHRzLndpbmRvd1xuICAgIH0pLFxuICAgIGh5ZHJhdGlvbkRhdGE6IChvcHRzID09IG51bGwgPyB2b2lkIDAgOiBvcHRzLmh5ZHJhdGlvbkRhdGEpIHx8IHBhcnNlSHlkcmF0aW9uRGF0YSgpLFxuICAgIHJvdXRlcyxcbiAgICBtYXBSb3V0ZVByb3BlcnRpZXM6IFVOU0FGRV9tYXBSb3V0ZVByb3BlcnRpZXMsXG4gICAgd2luZG93OiBvcHRzID09IG51bGwgPyB2b2lkIDAgOiBvcHRzLndpbmRvd1xuICB9KS5pbml0aWFsaXplKCk7XG59XG5mdW5jdGlvbiBwYXJzZUh5ZHJhdGlvbkRhdGEoKSB7XG4gIHZhciBfd2luZG93O1xuICBsZXQgc3RhdGUgPSAoX3dpbmRvdyA9IHdpbmRvdykgPT0gbnVsbCA/IHZvaWQgMCA6IF93aW5kb3cuX19zdGF0aWNSb3V0ZXJIeWRyYXRpb25EYXRhO1xuICBpZiAoc3RhdGUgJiYgc3RhdGUuZXJyb3JzKSB7XG4gICAgc3RhdGUgPSBfZXh0ZW5kcyh7fSwgc3RhdGUsIHtcbiAgICAgIGVycm9yczogZGVzZXJpYWxpemVFcnJvcnMoc3RhdGUuZXJyb3JzKVxuICAgIH0pO1xuICB9XG4gIHJldHVybiBzdGF0ZTtcbn1cbmZ1bmN0aW9uIGRlc2VyaWFsaXplRXJyb3JzKGVycm9ycykge1xuICBpZiAoIWVycm9ycykgcmV0dXJuIG51bGw7XG4gIGxldCBlbnRyaWVzID0gT2JqZWN0LmVudHJpZXMoZXJyb3JzKTtcbiAgbGV0IHNlcmlhbGl6ZWQgPSB7fTtcbiAgZm9yIChsZXQgW2tleSwgdmFsXSBvZiBlbnRyaWVzKSB7XG4gICAgLy8gSGV5IHlvdSEgIElmIHlvdSBjaGFuZ2UgdGhpcywgcGxlYXNlIGNoYW5nZSB0aGUgY29ycmVzcG9uZGluZyBsb2dpYyBpblxuICAgIC8vIHNlcmlhbGl6ZUVycm9ycyBpbiByZWFjdC1yb3V0ZXItZG9tL3NlcnZlci50c3ggOilcbiAgICBpZiAodmFsICYmIHZhbC5fX3R5cGUgPT09IFwiUm91dGVFcnJvclJlc3BvbnNlXCIpIHtcbiAgICAgIHNlcmlhbGl6ZWRba2V5XSA9IG5ldyBVTlNBRkVfRXJyb3JSZXNwb25zZUltcGwodmFsLnN0YXR1cywgdmFsLnN0YXR1c1RleHQsIHZhbC5kYXRhLCB2YWwuaW50ZXJuYWwgPT09IHRydWUpO1xuICAgIH0gZWxzZSBpZiAodmFsICYmIHZhbC5fX3R5cGUgPT09IFwiRXJyb3JcIikge1xuICAgICAgLy8gQXR0ZW1wdCB0byByZWNvbnN0cnVjdCB0aGUgcmlnaHQgdHlwZSBvZiBFcnJvciAoaS5lLiwgUmVmZXJlbmNlRXJyb3IpXG4gICAgICBpZiAodmFsLl9fc3ViVHlwZSkge1xuICAgICAgICBsZXQgRXJyb3JDb25zdHJ1Y3RvciA9IHdpbmRvd1t2YWwuX19zdWJUeXBlXTtcbiAgICAgICAgaWYgKHR5cGVvZiBFcnJvckNvbnN0cnVjdG9yID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgbGV0IGVycm9yID0gbmV3IEVycm9yQ29uc3RydWN0b3IodmFsLm1lc3NhZ2UpO1xuICAgICAgICAgICAgLy8gV2lwZSBhd2F5IHRoZSBjbGllbnQtc2lkZSBzdGFjayB0cmFjZS4gIE5vdGhpbmcgdG8gZmlsbCBpdCBpbiB3aXRoXG4gICAgICAgICAgICAvLyBiZWNhdXNlIHdlIGRvbid0IHNlcmlhbGl6ZSBTU1Igc3RhY2sgdHJhY2VzIGZvciBzZWN1cml0eSByZWFzb25zXG4gICAgICAgICAgICBlcnJvci5zdGFjayA9IFwiXCI7XG4gICAgICAgICAgICBzZXJpYWxpemVkW2tleV0gPSBlcnJvcjtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAvLyBuby1vcCAtIGZhbGwgdGhyb3VnaCBhbmQgY3JlYXRlIGEgbm9ybWFsIEVycm9yXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoc2VyaWFsaXplZFtrZXldID09IG51bGwpIHtcbiAgICAgICAgbGV0IGVycm9yID0gbmV3IEVycm9yKHZhbC5tZXNzYWdlKTtcbiAgICAgICAgLy8gV2lwZSBhd2F5IHRoZSBjbGllbnQtc2lkZSBzdGFjayB0cmFjZS4gIE5vdGhpbmcgdG8gZmlsbCBpdCBpbiB3aXRoXG4gICAgICAgIC8vIGJlY2F1c2Ugd2UgZG9uJ3Qgc2VyaWFsaXplIFNTUiBzdGFjayB0cmFjZXMgZm9yIHNlY3VyaXR5IHJlYXNvbnNcbiAgICAgICAgZXJyb3Iuc3RhY2sgPSBcIlwiO1xuICAgICAgICBzZXJpYWxpemVkW2tleV0gPSBlcnJvcjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc2VyaWFsaXplZFtrZXldID0gdmFsO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc2VyaWFsaXplZDtcbn1cbmNvbnN0IFZpZXdUcmFuc2l0aW9uQ29udGV4dCA9IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVDb250ZXh0KHtcbiAgaXNUcmFuc2l0aW9uaW5nOiBmYWxzZVxufSk7XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIFZpZXdUcmFuc2l0aW9uQ29udGV4dC5kaXNwbGF5TmFtZSA9IFwiVmlld1RyYW5zaXRpb25cIjtcbn1cbmNvbnN0IEZldGNoZXJzQ29udGV4dCA9IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVDb250ZXh0KG5ldyBNYXAoKSk7XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIEZldGNoZXJzQ29udGV4dC5kaXNwbGF5TmFtZSA9IFwiRmV0Y2hlcnNcIjtcbn1cbi8vI2VuZHJlZ2lvblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vI3JlZ2lvbiBDb21wb25lbnRzXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLyoqXG4gIFdlYnBhY2sgKyBSZWFjdCAxNyBmYWlscyB0byBjb21waWxlIG9uIGFueSBvZiB0aGUgZm9sbG93aW5nIGJlY2F1c2Ugd2VicGFja1xuICBjb21wbGFpbnMgdGhhdCBgc3RhcnRUcmFuc2l0aW9uYCBkb2Vzbid0IGV4aXN0IGluIGBSZWFjdGA6XG4gICogaW1wb3J0IHsgc3RhcnRUcmFuc2l0aW9uIH0gZnJvbSBcInJlYWN0XCJcbiAgKiBpbXBvcnQgKiBhcyBSZWFjdCBmcm9tIGZyb20gXCJyZWFjdFwiO1xuICAgIFwic3RhcnRUcmFuc2l0aW9uXCIgaW4gUmVhY3QgPyBSZWFjdC5zdGFydFRyYW5zaXRpb24oKCkgPT4gc2V0U3RhdGUoKSkgOiBzZXRTdGF0ZSgpXG4gICogaW1wb3J0ICogYXMgUmVhY3QgZnJvbSBmcm9tIFwicmVhY3RcIjtcbiAgICBcInN0YXJ0VHJhbnNpdGlvblwiIGluIFJlYWN0ID8gUmVhY3RbXCJzdGFydFRyYW5zaXRpb25cIl0oKCkgPT4gc2V0U3RhdGUoKSkgOiBzZXRTdGF0ZSgpXG5cbiAgTW92aW5nIGl0IHRvIGEgY29uc3RhbnQgc3VjaCBhcyB0aGUgZm9sbG93aW5nIHNvbHZlcyB0aGUgV2VicGFjay9SZWFjdCAxNyBpc3N1ZTpcbiAgKiBpbXBvcnQgKiBhcyBSZWFjdCBmcm9tIGZyb20gXCJyZWFjdFwiO1xuICAgIGNvbnN0IFNUQVJUX1RSQU5TSVRJT04gPSBcInN0YXJ0VHJhbnNpdGlvblwiO1xuICAgIFNUQVJUX1RSQU5TSVRJT04gaW4gUmVhY3QgPyBSZWFjdFtTVEFSVF9UUkFOU0lUSU9OXSgoKSA9PiBzZXRTdGF0ZSgpKSA6IHNldFN0YXRlKClcblxuICBIb3dldmVyLCB0aGF0IGludHJvZHVjZXMgd2VicGFjay90ZXJzZXIgbWluaWZpY2F0aW9uIGlzc3VlcyBpbiBwcm9kdWN0aW9uIGJ1aWxkc1xuICBpbiBSZWFjdCAxOCB3aGVyZSBtaW5pZmljYXRpb24vb2JmdXNjYXRpb24gZW5kcyB1cCByZW1vdmluZyB0aGUgY2FsbCBvZlxuICBSZWFjdC5zdGFydFRyYW5zaXRpb24gZW50aXJlbHkgZnJvbSB0aGUgZmlyc3QgaGFsZiBvZiB0aGUgdGVybmFyeS4gIEdyYWJiaW5nXG4gIHRoaXMgZXhwb3J0ZWQgcmVmZXJlbmNlIG9uY2UgdXAgZnJvbnQgcmVzb2x2ZXMgdGhhdCBpc3N1ZS5cblxuICBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3JlbWl4LXJ1bi9yZWFjdC1yb3V0ZXIvaXNzdWVzLzEwNTc5XG4qL1xuY29uc3QgU1RBUlRfVFJBTlNJVElPTiA9IFwic3RhcnRUcmFuc2l0aW9uXCI7XG5jb25zdCBzdGFydFRyYW5zaXRpb25JbXBsID0gUmVhY3RbU1RBUlRfVFJBTlNJVElPTl07XG5jb25zdCBGTFVTSF9TWU5DID0gXCJmbHVzaFN5bmNcIjtcbmNvbnN0IGZsdXNoU3luY0ltcGwgPSBSZWFjdERPTVtGTFVTSF9TWU5DXTtcbmZ1bmN0aW9uIHN0YXJ0VHJhbnNpdGlvblNhZmUoY2IpIHtcbiAgaWYgKHN0YXJ0VHJhbnNpdGlvbkltcGwpIHtcbiAgICBzdGFydFRyYW5zaXRpb25JbXBsKGNiKTtcbiAgfSBlbHNlIHtcbiAgICBjYigpO1xuICB9XG59XG5mdW5jdGlvbiBmbHVzaFN5bmNTYWZlKGNiKSB7XG4gIGlmIChmbHVzaFN5bmNJbXBsKSB7XG4gICAgZmx1c2hTeW5jSW1wbChjYik7XG4gIH0gZWxzZSB7XG4gICAgY2IoKTtcbiAgfVxufVxuY2xhc3MgRGVmZXJyZWQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLnN0YXR1cyA9IFwicGVuZGluZ1wiO1xuICAgIHRoaXMucHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMucmVzb2x2ZSA9IHZhbHVlID0+IHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdHVzID09PSBcInBlbmRpbmdcIikge1xuICAgICAgICAgIHRoaXMuc3RhdHVzID0gXCJyZXNvbHZlZFwiO1xuICAgICAgICAgIHJlc29sdmUodmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgdGhpcy5yZWplY3QgPSByZWFzb24gPT4ge1xuICAgICAgICBpZiAodGhpcy5zdGF0dXMgPT09IFwicGVuZGluZ1wiKSB7XG4gICAgICAgICAgdGhpcy5zdGF0dXMgPSBcInJlamVjdGVkXCI7XG4gICAgICAgICAgcmVqZWN0KHJlYXNvbik7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSk7XG4gIH1cbn1cbi8qKlxuICogR2l2ZW4gYSBSZW1peCBSb3V0ZXIgaW5zdGFuY2UsIHJlbmRlciB0aGUgYXBwcm9wcmlhdGUgVUlcbiAqL1xuZnVuY3Rpb24gUm91dGVyUHJvdmlkZXIoX3JlZikge1xuICBsZXQge1xuICAgIGZhbGxiYWNrRWxlbWVudCxcbiAgICByb3V0ZXIsXG4gICAgZnV0dXJlXG4gIH0gPSBfcmVmO1xuICBsZXQgW3N0YXRlLCBzZXRTdGF0ZUltcGxdID0gUmVhY3QudXNlU3RhdGUocm91dGVyLnN0YXRlKTtcbiAgbGV0IFtwZW5kaW5nU3RhdGUsIHNldFBlbmRpbmdTdGF0ZV0gPSBSZWFjdC51c2VTdGF0ZSgpO1xuICBsZXQgW3Z0Q29udGV4dCwgc2V0VnRDb250ZXh0XSA9IFJlYWN0LnVzZVN0YXRlKHtcbiAgICBpc1RyYW5zaXRpb25pbmc6IGZhbHNlXG4gIH0pO1xuICBsZXQgW3JlbmRlckRmZCwgc2V0UmVuZGVyRGZkXSA9IFJlYWN0LnVzZVN0YXRlKCk7XG4gIGxldCBbdHJhbnNpdGlvbiwgc2V0VHJhbnNpdGlvbl0gPSBSZWFjdC51c2VTdGF0ZSgpO1xuICBsZXQgW2ludGVycnVwdGlvbiwgc2V0SW50ZXJydXB0aW9uXSA9IFJlYWN0LnVzZVN0YXRlKCk7XG4gIGxldCBmZXRjaGVyRGF0YSA9IFJlYWN0LnVzZVJlZihuZXcgTWFwKCkpO1xuICBsZXQge1xuICAgIHY3X3N0YXJ0VHJhbnNpdGlvblxuICB9ID0gZnV0dXJlIHx8IHt9O1xuICBsZXQgb3B0SW5TdGFydFRyYW5zaXRpb24gPSBSZWFjdC51c2VDYWxsYmFjayhjYiA9PiB7XG4gICAgaWYgKHY3X3N0YXJ0VHJhbnNpdGlvbikge1xuICAgICAgc3RhcnRUcmFuc2l0aW9uU2FmZShjYik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNiKCk7XG4gICAgfVxuICB9LCBbdjdfc3RhcnRUcmFuc2l0aW9uXSk7XG4gIGxldCBzZXRTdGF0ZSA9IFJlYWN0LnVzZUNhbGxiYWNrKChuZXdTdGF0ZSwgX3JlZjIpID0+IHtcbiAgICBsZXQge1xuICAgICAgZGVsZXRlZEZldGNoZXJzLFxuICAgICAgdW5zdGFibGVfZmx1c2hTeW5jOiBmbHVzaFN5bmMsXG4gICAgICB1bnN0YWJsZV92aWV3VHJhbnNpdGlvbk9wdHM6IHZpZXdUcmFuc2l0aW9uT3B0c1xuICAgIH0gPSBfcmVmMjtcbiAgICBkZWxldGVkRmV0Y2hlcnMuZm9yRWFjaChrZXkgPT4gZmV0Y2hlckRhdGEuY3VycmVudC5kZWxldGUoa2V5KSk7XG4gICAgbmV3U3RhdGUuZmV0Y2hlcnMuZm9yRWFjaCgoZmV0Y2hlciwga2V5KSA9PiB7XG4gICAgICBpZiAoZmV0Y2hlci5kYXRhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZmV0Y2hlckRhdGEuY3VycmVudC5zZXQoa2V5LCBmZXRjaGVyLmRhdGEpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGxldCBpc1ZpZXdUcmFuc2l0aW9uVW5hdmFpbGFibGUgPSByb3V0ZXIud2luZG93ID09IG51bGwgfHwgdHlwZW9mIHJvdXRlci53aW5kb3cuZG9jdW1lbnQuc3RhcnRWaWV3VHJhbnNpdGlvbiAhPT0gXCJmdW5jdGlvblwiO1xuICAgIC8vIElmIHRoaXMgaXNuJ3QgYSB2aWV3IHRyYW5zaXRpb24gb3IgaXQncyBub3QgYXZhaWxhYmxlIGluIHRoaXMgYnJvd3NlcixcbiAgICAvLyBqdXN0IHVwZGF0ZSBhbmQgYmUgZG9uZSB3aXRoIGl0XG4gICAgaWYgKCF2aWV3VHJhbnNpdGlvbk9wdHMgfHwgaXNWaWV3VHJhbnNpdGlvblVuYXZhaWxhYmxlKSB7XG4gICAgICBpZiAoZmx1c2hTeW5jKSB7XG4gICAgICAgIGZsdXNoU3luY1NhZmUoKCkgPT4gc2V0U3RhdGVJbXBsKG5ld1N0YXRlKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvcHRJblN0YXJ0VHJhbnNpdGlvbigoKSA9PiBzZXRTdGF0ZUltcGwobmV3U3RhdGUpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gZmx1c2hTeW5jICsgc3RhcnRWaWV3VHJhbnNpdGlvblxuICAgIGlmIChmbHVzaFN5bmMpIHtcbiAgICAgIC8vIEZsdXNoIHRocm91Z2ggdGhlIGNvbnRleHQgdG8gbWFyayBET00gZWxlbWVudHMgYXMgdHJhbnNpdGlvbj1pbmdcbiAgICAgIGZsdXNoU3luY1NhZmUoKCkgPT4ge1xuICAgICAgICAvLyBDYW5jZWwgYW55IHBlbmRpbmcgdHJhbnNpdGlvbnNcbiAgICAgICAgaWYgKHRyYW5zaXRpb24pIHtcbiAgICAgICAgICByZW5kZXJEZmQgJiYgcmVuZGVyRGZkLnJlc29sdmUoKTtcbiAgICAgICAgICB0cmFuc2l0aW9uLnNraXBUcmFuc2l0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VnRDb250ZXh0KHtcbiAgICAgICAgICBpc1RyYW5zaXRpb25pbmc6IHRydWUsXG4gICAgICAgICAgZmx1c2hTeW5jOiB0cnVlLFxuICAgICAgICAgIGN1cnJlbnRMb2NhdGlvbjogdmlld1RyYW5zaXRpb25PcHRzLmN1cnJlbnRMb2NhdGlvbixcbiAgICAgICAgICBuZXh0TG9jYXRpb246IHZpZXdUcmFuc2l0aW9uT3B0cy5uZXh0TG9jYXRpb25cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIC8vIFVwZGF0ZSB0aGUgRE9NXG4gICAgICBsZXQgdCA9IHJvdXRlci53aW5kb3cuZG9jdW1lbnQuc3RhcnRWaWV3VHJhbnNpdGlvbigoKSA9PiB7XG4gICAgICAgIGZsdXNoU3luY1NhZmUoKCkgPT4gc2V0U3RhdGVJbXBsKG5ld1N0YXRlKSk7XG4gICAgICB9KTtcbiAgICAgIC8vIENsZWFuIHVwIGFmdGVyIHRoZSBhbmltYXRpb24gY29tcGxldGVzXG4gICAgICB0LmZpbmlzaGVkLmZpbmFsbHkoKCkgPT4ge1xuICAgICAgICBmbHVzaFN5bmNTYWZlKCgpID0+IHtcbiAgICAgICAgICBzZXRSZW5kZXJEZmQodW5kZWZpbmVkKTtcbiAgICAgICAgICBzZXRUcmFuc2l0aW9uKHVuZGVmaW5lZCk7XG4gICAgICAgICAgc2V0UGVuZGluZ1N0YXRlKHVuZGVmaW5lZCk7XG4gICAgICAgICAgc2V0VnRDb250ZXh0KHtcbiAgICAgICAgICAgIGlzVHJhbnNpdGlvbmluZzogZmFsc2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIGZsdXNoU3luY1NhZmUoKCkgPT4gc2V0VHJhbnNpdGlvbih0KSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIHN0YXJ0VHJhbnNpdGlvbiArIHN0YXJ0Vmlld1RyYW5zaXRpb25cbiAgICBpZiAodHJhbnNpdGlvbikge1xuICAgICAgLy8gSW50ZXJydXB0aW5nIGFuIGluLXByb2dyZXNzIHRyYW5zaXRpb24sIGNhbmNlbCBhbmQgbGV0IGV2ZXJ5dGhpbmcgZmx1c2hcbiAgICAgIC8vIG91dCwgYW5kIHRoZW4ga2ljayBvZmYgYSBuZXcgdHJhbnNpdGlvbiBmcm9tIHRoZSBpbnRlcnJ1cHRpb24gc3RhdGVcbiAgICAgIHJlbmRlckRmZCAmJiByZW5kZXJEZmQucmVzb2x2ZSgpO1xuICAgICAgdHJhbnNpdGlvbi5za2lwVHJhbnNpdGlvbigpO1xuICAgICAgc2V0SW50ZXJydXB0aW9uKHtcbiAgICAgICAgc3RhdGU6IG5ld1N0YXRlLFxuICAgICAgICBjdXJyZW50TG9jYXRpb246IHZpZXdUcmFuc2l0aW9uT3B0cy5jdXJyZW50TG9jYXRpb24sXG4gICAgICAgIG5leHRMb2NhdGlvbjogdmlld1RyYW5zaXRpb25PcHRzLm5leHRMb2NhdGlvblxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIENvbXBsZXRlZCBuYXZpZ2F0aW9uIHVwZGF0ZSB3aXRoIG9wdGVkLWluIHZpZXcgdHJhbnNpdGlvbnMsIGxldCAnZXIgcmlwXG4gICAgICBzZXRQZW5kaW5nU3RhdGUobmV3U3RhdGUpO1xuICAgICAgc2V0VnRDb250ZXh0KHtcbiAgICAgICAgaXNUcmFuc2l0aW9uaW5nOiB0cnVlLFxuICAgICAgICBmbHVzaFN5bmM6IGZhbHNlLFxuICAgICAgICBjdXJyZW50TG9jYXRpb246IHZpZXdUcmFuc2l0aW9uT3B0cy5jdXJyZW50TG9jYXRpb24sXG4gICAgICAgIG5leHRMb2NhdGlvbjogdmlld1RyYW5zaXRpb25PcHRzLm5leHRMb2NhdGlvblxuICAgICAgfSk7XG4gICAgfVxuICB9LCBbcm91dGVyLndpbmRvdywgdHJhbnNpdGlvbiwgcmVuZGVyRGZkLCBmZXRjaGVyRGF0YSwgb3B0SW5TdGFydFRyYW5zaXRpb25dKTtcbiAgLy8gTmVlZCB0byB1c2UgYSBsYXlvdXQgZWZmZWN0IGhlcmUgc28gd2UgYXJlIHN1YnNjcmliZWQgZWFybHkgZW5vdWdoIHRvXG4gIC8vIHBpY2sgdXAgb24gYW55IHJlbmRlci1kcml2ZW4gcmVkaXJlY3RzL25hdmlnYXRpb25zICh1c2VFZmZlY3QvPE5hdmlnYXRlPilcbiAgUmVhY3QudXNlTGF5b3V0RWZmZWN0KCgpID0+IHJvdXRlci5zdWJzY3JpYmUoc2V0U3RhdGUpLCBbcm91dGVyLCBzZXRTdGF0ZV0pO1xuICAvLyBXaGVuIHdlIHN0YXJ0IGEgdmlldyB0cmFuc2l0aW9uLCBjcmVhdGUgYSBEZWZlcnJlZCB3ZSBjYW4gdXNlIGZvciB0aGVcbiAgLy8gZXZlbnR1YWwgXCJjb21wbGV0ZWRcIiByZW5kZXJcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAodnRDb250ZXh0LmlzVHJhbnNpdGlvbmluZyAmJiAhdnRDb250ZXh0LmZsdXNoU3luYykge1xuICAgICAgc2V0UmVuZGVyRGZkKG5ldyBEZWZlcnJlZCgpKTtcbiAgICB9XG4gIH0sIFt2dENvbnRleHRdKTtcbiAgLy8gT25jZSB0aGUgZGVmZXJyZWQgaXMgY3JlYXRlZCwga2ljayBvZmYgc3RhcnRWaWV3VHJhbnNpdGlvbigpIHRvIHVwZGF0ZSB0aGVcbiAgLy8gRE9NIGFuZCB0aGVuIHdhaXQgb24gdGhlIERlZmVycmVkIHRvIHJlc29sdmUgKGluZGljYXRpbmcgdGhlIERPTSB1cGRhdGUgaGFzXG4gIC8vIGhhcHBlbmVkKVxuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChyZW5kZXJEZmQgJiYgcGVuZGluZ1N0YXRlICYmIHJvdXRlci53aW5kb3cpIHtcbiAgICAgIGxldCBuZXdTdGF0ZSA9IHBlbmRpbmdTdGF0ZTtcbiAgICAgIGxldCByZW5kZXJQcm9taXNlID0gcmVuZGVyRGZkLnByb21pc2U7XG4gICAgICBsZXQgdHJhbnNpdGlvbiA9IHJvdXRlci53aW5kb3cuZG9jdW1lbnQuc3RhcnRWaWV3VHJhbnNpdGlvbihhc3luYyAoKSA9PiB7XG4gICAgICAgIG9wdEluU3RhcnRUcmFuc2l0aW9uKCgpID0+IHNldFN0YXRlSW1wbChuZXdTdGF0ZSkpO1xuICAgICAgICBhd2FpdCByZW5kZXJQcm9taXNlO1xuICAgICAgfSk7XG4gICAgICB0cmFuc2l0aW9uLmZpbmlzaGVkLmZpbmFsbHkoKCkgPT4ge1xuICAgICAgICBzZXRSZW5kZXJEZmQodW5kZWZpbmVkKTtcbiAgICAgICAgc2V0VHJhbnNpdGlvbih1bmRlZmluZWQpO1xuICAgICAgICBzZXRQZW5kaW5nU3RhdGUodW5kZWZpbmVkKTtcbiAgICAgICAgc2V0VnRDb250ZXh0KHtcbiAgICAgICAgICBpc1RyYW5zaXRpb25pbmc6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICBzZXRUcmFuc2l0aW9uKHRyYW5zaXRpb24pO1xuICAgIH1cbiAgfSwgW29wdEluU3RhcnRUcmFuc2l0aW9uLCBwZW5kaW5nU3RhdGUsIHJlbmRlckRmZCwgcm91dGVyLndpbmRvd10pO1xuICAvLyBXaGVuIHRoZSBuZXcgbG9jYXRpb24gZmluYWxseSByZW5kZXJzIGFuZCBpcyBjb21taXR0ZWQgdG8gdGhlIERPTSwgdGhpc1xuICAvLyBlZmZlY3Qgd2lsbCBydW4gdG8gcmVzb2x2ZSB0aGUgdHJhbnNpdGlvblxuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChyZW5kZXJEZmQgJiYgcGVuZGluZ1N0YXRlICYmIHN0YXRlLmxvY2F0aW9uLmtleSA9PT0gcGVuZGluZ1N0YXRlLmxvY2F0aW9uLmtleSkge1xuICAgICAgcmVuZGVyRGZkLnJlc29sdmUoKTtcbiAgICB9XG4gIH0sIFtyZW5kZXJEZmQsIHRyYW5zaXRpb24sIHN0YXRlLmxvY2F0aW9uLCBwZW5kaW5nU3RhdGVdKTtcbiAgLy8gSWYgd2UgZ2V0IGludGVycnVwdGVkIHdpdGggYSBuZXcgbmF2aWdhdGlvbiBkdXJpbmcgYSB0cmFuc2l0aW9uLCB3ZSBza2lwXG4gIC8vIHRoZSBhY3RpdmUgdHJhbnNpdGlvbiwgbGV0IGl0IGNsZWFudXAsIHRoZW4ga2ljayBpdCBvZmYgYWdhaW4gaGVyZVxuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghdnRDb250ZXh0LmlzVHJhbnNpdGlvbmluZyAmJiBpbnRlcnJ1cHRpb24pIHtcbiAgICAgIHNldFBlbmRpbmdTdGF0ZShpbnRlcnJ1cHRpb24uc3RhdGUpO1xuICAgICAgc2V0VnRDb250ZXh0KHtcbiAgICAgICAgaXNUcmFuc2l0aW9uaW5nOiB0cnVlLFxuICAgICAgICBmbHVzaFN5bmM6IGZhbHNlLFxuICAgICAgICBjdXJyZW50TG9jYXRpb246IGludGVycnVwdGlvbi5jdXJyZW50TG9jYXRpb24sXG4gICAgICAgIG5leHRMb2NhdGlvbjogaW50ZXJydXB0aW9uLm5leHRMb2NhdGlvblxuICAgICAgfSk7XG4gICAgICBzZXRJbnRlcnJ1cHRpb24odW5kZWZpbmVkKTtcbiAgICB9XG4gIH0sIFt2dENvbnRleHQuaXNUcmFuc2l0aW9uaW5nLCBpbnRlcnJ1cHRpb25dKTtcbiAgbGV0IG5hdmlnYXRvciA9IFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBjcmVhdGVIcmVmOiByb3V0ZXIuY3JlYXRlSHJlZixcbiAgICAgIGVuY29kZUxvY2F0aW9uOiByb3V0ZXIuZW5jb2RlTG9jYXRpb24sXG4gICAgICBnbzogbiA9PiByb3V0ZXIubmF2aWdhdGUobiksXG4gICAgICBwdXNoOiAodG8sIHN0YXRlLCBvcHRzKSA9PiByb3V0ZXIubmF2aWdhdGUodG8sIHtcbiAgICAgICAgc3RhdGUsXG4gICAgICAgIHByZXZlbnRTY3JvbGxSZXNldDogb3B0cyA9PSBudWxsID8gdm9pZCAwIDogb3B0cy5wcmV2ZW50U2Nyb2xsUmVzZXRcbiAgICAgIH0pLFxuICAgICAgcmVwbGFjZTogKHRvLCBzdGF0ZSwgb3B0cykgPT4gcm91dGVyLm5hdmlnYXRlKHRvLCB7XG4gICAgICAgIHJlcGxhY2U6IHRydWUsXG4gICAgICAgIHN0YXRlLFxuICAgICAgICBwcmV2ZW50U2Nyb2xsUmVzZXQ6IG9wdHMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdHMucHJldmVudFNjcm9sbFJlc2V0XG4gICAgICB9KVxuICAgIH07XG4gIH0sIFtyb3V0ZXJdKTtcbiAgbGV0IGJhc2VuYW1lID0gcm91dGVyLmJhc2VuYW1lIHx8IFwiL1wiO1xuICBsZXQgZGF0YVJvdXRlckNvbnRleHQgPSBSZWFjdC51c2VNZW1vKCgpID0+ICh7XG4gICAgcm91dGVyLFxuICAgIG5hdmlnYXRvcixcbiAgICBzdGF0aWM6IGZhbHNlLFxuICAgIGJhc2VuYW1lXG4gIH0pLCBbcm91dGVyLCBuYXZpZ2F0b3IsIGJhc2VuYW1lXSk7XG4gIC8vIFRoZSBmcmFnbWVudCBhbmQge251bGx9IGhlcmUgYXJlIGltcG9ydGFudCEgIFdlIG5lZWQgdGhlbSB0byBrZWVwIFJlYWN0IDE4J3NcbiAgLy8gdXNlSWQgaGFwcHkgd2hlbiB3ZSBhcmUgc2VydmVyLXJlbmRlcmluZyBzaW5jZSB3ZSBtYXkgaGF2ZSBhIDxzY3JpcHQ+IGhlcmVcbiAgLy8gY29udGFpbmluZyB0aGUgaHlkcmF0ZWQgc2VydmVyLXNpZGUgc3RhdGljQ29udGV4dCAoZnJvbSBTdGF0aWNSb3V0ZXJQcm92aWRlcikuXG4gIC8vIHVzZUlkIHJlbGllcyBvbiB0aGUgY29tcG9uZW50IHRyZWUgc3RydWN0dXJlIHRvIGdlbmVyYXRlIGRldGVybWluaXN0aWMgaWQnc1xuICAvLyBzbyB3ZSBuZWVkIHRvIGVuc3VyZSBpdCByZW1haW5zIHRoZSBzYW1lIG9uIHRoZSBjbGllbnQgZXZlbiB0aG91Z2hcbiAgLy8gd2UgZG9uJ3QgbmVlZCB0aGUgPHNjcmlwdD4gdGFnXG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoVU5TQUZFX0RhdGFSb3V0ZXJDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IGRhdGFSb3V0ZXJDb250ZXh0XG4gIH0sIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFVOU0FGRV9EYXRhUm91dGVyU3RhdGVDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IHN0YXRlXG4gIH0sIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEZldGNoZXJzQ29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiBmZXRjaGVyRGF0YS5jdXJyZW50XG4gIH0sIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFZpZXdUcmFuc2l0aW9uQ29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiB2dENvbnRleHRcbiAgfSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUm91dGVyLCB7XG4gICAgYmFzZW5hbWU6IGJhc2VuYW1lLFxuICAgIGxvY2F0aW9uOiBzdGF0ZS5sb2NhdGlvbixcbiAgICBuYXZpZ2F0aW9uVHlwZTogc3RhdGUuaGlzdG9yeUFjdGlvbixcbiAgICBuYXZpZ2F0b3I6IG5hdmlnYXRvclxuICB9LCBzdGF0ZS5pbml0aWFsaXplZCA/IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KERhdGFSb3V0ZXMsIHtcbiAgICByb3V0ZXM6IHJvdXRlci5yb3V0ZXMsXG4gICAgc3RhdGU6IHN0YXRlXG4gIH0pIDogZmFsbGJhY2tFbGVtZW50KSkpKSksIG51bGwpO1xufVxuZnVuY3Rpb24gRGF0YVJvdXRlcyhfcmVmMykge1xuICBsZXQge1xuICAgIHJvdXRlcyxcbiAgICBzdGF0ZVxuICB9ID0gX3JlZjM7XG4gIHJldHVybiBVTlNBRkVfdXNlUm91dGVzSW1wbChyb3V0ZXMsIHVuZGVmaW5lZCwgc3RhdGUpO1xufVxuLyoqXG4gKiBBIGA8Um91dGVyPmAgZm9yIHVzZSBpbiB3ZWIgYnJvd3NlcnMuIFByb3ZpZGVzIHRoZSBjbGVhbmVzdCBVUkxzLlxuICovXG5mdW5jdGlvbiBCcm93c2VyUm91dGVyKF9yZWY0KSB7XG4gIGxldCB7XG4gICAgYmFzZW5hbWUsXG4gICAgY2hpbGRyZW4sXG4gICAgZnV0dXJlLFxuICAgIHdpbmRvd1xuICB9ID0gX3JlZjQ7XG4gIGxldCBoaXN0b3J5UmVmID0gUmVhY3QudXNlUmVmKCk7XG4gIGlmIChoaXN0b3J5UmVmLmN1cnJlbnQgPT0gbnVsbCkge1xuICAgIGhpc3RvcnlSZWYuY3VycmVudCA9IGNyZWF0ZUJyb3dzZXJIaXN0b3J5KHtcbiAgICAgIHdpbmRvdyxcbiAgICAgIHY1Q29tcGF0OiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgbGV0IGhpc3RvcnkgPSBoaXN0b3J5UmVmLmN1cnJlbnQ7XG4gIGxldCBbc3RhdGUsIHNldFN0YXRlSW1wbF0gPSBSZWFjdC51c2VTdGF0ZSh7XG4gICAgYWN0aW9uOiBoaXN0b3J5LmFjdGlvbixcbiAgICBsb2NhdGlvbjogaGlzdG9yeS5sb2NhdGlvblxuICB9KTtcbiAgbGV0IHtcbiAgICB2N19zdGFydFRyYW5zaXRpb25cbiAgfSA9IGZ1dHVyZSB8fCB7fTtcbiAgbGV0IHNldFN0YXRlID0gUmVhY3QudXNlQ2FsbGJhY2sobmV3U3RhdGUgPT4ge1xuICAgIHY3X3N0YXJ0VHJhbnNpdGlvbiAmJiBzdGFydFRyYW5zaXRpb25JbXBsID8gc3RhcnRUcmFuc2l0aW9uSW1wbCgoKSA9PiBzZXRTdGF0ZUltcGwobmV3U3RhdGUpKSA6IHNldFN0YXRlSW1wbChuZXdTdGF0ZSk7XG4gIH0sIFtzZXRTdGF0ZUltcGwsIHY3X3N0YXJ0VHJhbnNpdGlvbl0pO1xuICBSZWFjdC51c2VMYXlvdXRFZmZlY3QoKCkgPT4gaGlzdG9yeS5saXN0ZW4oc2V0U3RhdGUpLCBbaGlzdG9yeSwgc2V0U3RhdGVdKTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFJvdXRlciwge1xuICAgIGJhc2VuYW1lOiBiYXNlbmFtZSxcbiAgICBjaGlsZHJlbjogY2hpbGRyZW4sXG4gICAgbG9jYXRpb246IHN0YXRlLmxvY2F0aW9uLFxuICAgIG5hdmlnYXRpb25UeXBlOiBzdGF0ZS5hY3Rpb24sXG4gICAgbmF2aWdhdG9yOiBoaXN0b3J5XG4gIH0pO1xufVxuLyoqXG4gKiBBIGA8Um91dGVyPmAgZm9yIHVzZSBpbiB3ZWIgYnJvd3NlcnMuIFN0b3JlcyB0aGUgbG9jYXRpb24gaW4gdGhlIGhhc2hcbiAqIHBvcnRpb24gb2YgdGhlIFVSTCBzbyBpdCBpcyBub3Qgc2VudCB0byB0aGUgc2VydmVyLlxuICovXG5mdW5jdGlvbiBIYXNoUm91dGVyKF9yZWY1KSB7XG4gIGxldCB7XG4gICAgYmFzZW5hbWUsXG4gICAgY2hpbGRyZW4sXG4gICAgZnV0dXJlLFxuICAgIHdpbmRvd1xuICB9ID0gX3JlZjU7XG4gIGxldCBoaXN0b3J5UmVmID0gUmVhY3QudXNlUmVmKCk7XG4gIGlmIChoaXN0b3J5UmVmLmN1cnJlbnQgPT0gbnVsbCkge1xuICAgIGhpc3RvcnlSZWYuY3VycmVudCA9IGNyZWF0ZUhhc2hIaXN0b3J5KHtcbiAgICAgIHdpbmRvdyxcbiAgICAgIHY1Q29tcGF0OiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgbGV0IGhpc3RvcnkgPSBoaXN0b3J5UmVmLmN1cnJlbnQ7XG4gIGxldCBbc3RhdGUsIHNldFN0YXRlSW1wbF0gPSBSZWFjdC51c2VTdGF0ZSh7XG4gICAgYWN0aW9uOiBoaXN0b3J5LmFjdGlvbixcbiAgICBsb2NhdGlvbjogaGlzdG9yeS5sb2NhdGlvblxuICB9KTtcbiAgbGV0IHtcbiAgICB2N19zdGFydFRyYW5zaXRpb25cbiAgfSA9IGZ1dHVyZSB8fCB7fTtcbiAgbGV0IHNldFN0YXRlID0gUmVhY3QudXNlQ2FsbGJhY2sobmV3U3RhdGUgPT4ge1xuICAgIHY3X3N0YXJ0VHJhbnNpdGlvbiAmJiBzdGFydFRyYW5zaXRpb25JbXBsID8gc3RhcnRUcmFuc2l0aW9uSW1wbCgoKSA9PiBzZXRTdGF0ZUltcGwobmV3U3RhdGUpKSA6IHNldFN0YXRlSW1wbChuZXdTdGF0ZSk7XG4gIH0sIFtzZXRTdGF0ZUltcGwsIHY3X3N0YXJ0VHJhbnNpdGlvbl0pO1xuICBSZWFjdC51c2VMYXlvdXRFZmZlY3QoKCkgPT4gaGlzdG9yeS5saXN0ZW4oc2V0U3RhdGUpLCBbaGlzdG9yeSwgc2V0U3RhdGVdKTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFJvdXRlciwge1xuICAgIGJhc2VuYW1lOiBiYXNlbmFtZSxcbiAgICBjaGlsZHJlbjogY2hpbGRyZW4sXG4gICAgbG9jYXRpb246IHN0YXRlLmxvY2F0aW9uLFxuICAgIG5hdmlnYXRpb25UeXBlOiBzdGF0ZS5hY3Rpb24sXG4gICAgbmF2aWdhdG9yOiBoaXN0b3J5XG4gIH0pO1xufVxuLyoqXG4gKiBBIGA8Um91dGVyPmAgdGhhdCBhY2NlcHRzIGEgcHJlLWluc3RhbnRpYXRlZCBoaXN0b3J5IG9iamVjdC4gSXQncyBpbXBvcnRhbnRcbiAqIHRvIG5vdGUgdGhhdCB1c2luZyB5b3VyIG93biBoaXN0b3J5IG9iamVjdCBpcyBoaWdobHkgZGlzY291cmFnZWQgYW5kIG1heSBhZGRcbiAqIHR3byB2ZXJzaW9ucyBvZiB0aGUgaGlzdG9yeSBsaWJyYXJ5IHRvIHlvdXIgYnVuZGxlcyB1bmxlc3MgeW91IHVzZSB0aGUgc2FtZVxuICogdmVyc2lvbiBvZiB0aGUgaGlzdG9yeSBsaWJyYXJ5IHRoYXQgUmVhY3QgUm91dGVyIHVzZXMgaW50ZXJuYWxseS5cbiAqL1xuZnVuY3Rpb24gSGlzdG9yeVJvdXRlcihfcmVmNikge1xuICBsZXQge1xuICAgIGJhc2VuYW1lLFxuICAgIGNoaWxkcmVuLFxuICAgIGZ1dHVyZSxcbiAgICBoaXN0b3J5XG4gIH0gPSBfcmVmNjtcbiAgbGV0IFtzdGF0ZSwgc2V0U3RhdGVJbXBsXSA9IFJlYWN0LnVzZVN0YXRlKHtcbiAgICBhY3Rpb246IGhpc3RvcnkuYWN0aW9uLFxuICAgIGxvY2F0aW9uOiBoaXN0b3J5LmxvY2F0aW9uXG4gIH0pO1xuICBsZXQge1xuICAgIHY3X3N0YXJ0VHJhbnNpdGlvblxuICB9ID0gZnV0dXJlIHx8IHt9O1xuICBsZXQgc2V0U3RhdGUgPSBSZWFjdC51c2VDYWxsYmFjayhuZXdTdGF0ZSA9PiB7XG4gICAgdjdfc3RhcnRUcmFuc2l0aW9uICYmIHN0YXJ0VHJhbnNpdGlvbkltcGwgPyBzdGFydFRyYW5zaXRpb25JbXBsKCgpID0+IHNldFN0YXRlSW1wbChuZXdTdGF0ZSkpIDogc2V0U3RhdGVJbXBsKG5ld1N0YXRlKTtcbiAgfSwgW3NldFN0YXRlSW1wbCwgdjdfc3RhcnRUcmFuc2l0aW9uXSk7XG4gIFJlYWN0LnVzZUxheW91dEVmZmVjdCgoKSA9PiBoaXN0b3J5Lmxpc3RlbihzZXRTdGF0ZSksIFtoaXN0b3J5LCBzZXRTdGF0ZV0pO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUm91dGVyLCB7XG4gICAgYmFzZW5hbWU6IGJhc2VuYW1lLFxuICAgIGNoaWxkcmVuOiBjaGlsZHJlbixcbiAgICBsb2NhdGlvbjogc3RhdGUubG9jYXRpb24sXG4gICAgbmF2aWdhdGlvblR5cGU6IHN0YXRlLmFjdGlvbixcbiAgICBuYXZpZ2F0b3I6IGhpc3RvcnlcbiAgfSk7XG59XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIEhpc3RvcnlSb3V0ZXIuZGlzcGxheU5hbWUgPSBcInVuc3RhYmxlX0hpc3RvcnlSb3V0ZXJcIjtcbn1cbmNvbnN0IGlzQnJvd3NlciA9IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2Ygd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgIT09IFwidW5kZWZpbmVkXCI7XG5jb25zdCBBQlNPTFVURV9VUkxfUkVHRVggPSAvXig/OlthLXpdW2EtejAtOSsuLV0qOnxcXC9cXC8pL2k7XG4vKipcbiAqIFRoZSBwdWJsaWMgQVBJIGZvciByZW5kZXJpbmcgYSBoaXN0b3J5LWF3YXJlIGA8YT5gLlxuICovXG5jb25zdCBMaW5rID0gLyojX19QVVJFX18qL1JlYWN0LmZvcndhcmRSZWYoZnVuY3Rpb24gTGlua1dpdGhSZWYoX3JlZjcsIHJlZikge1xuICBsZXQge1xuICAgICAgb25DbGljayxcbiAgICAgIHJlbGF0aXZlLFxuICAgICAgcmVsb2FkRG9jdW1lbnQsXG4gICAgICByZXBsYWNlLFxuICAgICAgc3RhdGUsXG4gICAgICB0YXJnZXQsXG4gICAgICB0byxcbiAgICAgIHByZXZlbnRTY3JvbGxSZXNldCxcbiAgICAgIHVuc3RhYmxlX3ZpZXdUcmFuc2l0aW9uXG4gICAgfSA9IF9yZWY3LFxuICAgIHJlc3QgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShfcmVmNywgX2V4Y2x1ZGVkKTtcbiAgbGV0IHtcbiAgICBiYXNlbmFtZVxuICB9ID0gUmVhY3QudXNlQ29udGV4dChVTlNBRkVfTmF2aWdhdGlvbkNvbnRleHQpO1xuICAvLyBSZW5kZXJlZCBpbnRvIDxhIGhyZWY+IGZvciBhYnNvbHV0ZSBVUkxzXG4gIGxldCBhYnNvbHV0ZUhyZWY7XG4gIGxldCBpc0V4dGVybmFsID0gZmFsc2U7XG4gIGlmICh0eXBlb2YgdG8gPT09IFwic3RyaW5nXCIgJiYgQUJTT0xVVEVfVVJMX1JFR0VYLnRlc3QodG8pKSB7XG4gICAgLy8gUmVuZGVyIHRoZSBhYnNvbHV0ZSBocmVmIHNlcnZlci0gYW5kIGNsaWVudC1zaWRlXG4gICAgYWJzb2x1dGVIcmVmID0gdG87XG4gICAgLy8gT25seSBjaGVjayBmb3IgZXh0ZXJuYWwgb3JpZ2lucyBjbGllbnQtc2lkZVxuICAgIGlmIChpc0Jyb3dzZXIpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGxldCBjdXJyZW50VXJsID0gbmV3IFVSTCh3aW5kb3cubG9jYXRpb24uaHJlZik7XG4gICAgICAgIGxldCB0YXJnZXRVcmwgPSB0by5zdGFydHNXaXRoKFwiLy9cIikgPyBuZXcgVVJMKGN1cnJlbnRVcmwucHJvdG9jb2wgKyB0bykgOiBuZXcgVVJMKHRvKTtcbiAgICAgICAgbGV0IHBhdGggPSBzdHJpcEJhc2VuYW1lKHRhcmdldFVybC5wYXRobmFtZSwgYmFzZW5hbWUpO1xuICAgICAgICBpZiAodGFyZ2V0VXJsLm9yaWdpbiA9PT0gY3VycmVudFVybC5vcmlnaW4gJiYgcGF0aCAhPSBudWxsKSB7XG4gICAgICAgICAgLy8gU3RyaXAgdGhlIHByb3RvY29sL29yaWdpbi9iYXNlbmFtZSBmb3Igc2FtZS1vcmlnaW4gYWJzb2x1dGUgVVJMc1xuICAgICAgICAgIHRvID0gcGF0aCArIHRhcmdldFVybC5zZWFyY2ggKyB0YXJnZXRVcmwuaGFzaDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpc0V4dGVybmFsID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAvLyBXZSBjYW4ndCBkbyBleHRlcm5hbCBVUkwgZGV0ZWN0aW9uIHdpdGhvdXQgYSB2YWxpZCBVUkxcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gVU5TQUZFX3dhcm5pbmcoZmFsc2UsIFwiPExpbmsgdG89XFxcIlwiICsgdG8gKyBcIlxcXCI+IGNvbnRhaW5zIGFuIGludmFsaWQgVVJMIHdoaWNoIHdpbGwgcHJvYmFibHkgYnJlYWsgXCIgKyBcIndoZW4gY2xpY2tlZCAtIHBsZWFzZSB1cGRhdGUgdG8gYSB2YWxpZCBVUkwgcGF0aC5cIikgOiB2b2lkIDA7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8vIFJlbmRlcmVkIGludG8gPGEgaHJlZj4gZm9yIHJlbGF0aXZlIFVSTHNcbiAgbGV0IGhyZWYgPSB1c2VIcmVmKHRvLCB7XG4gICAgcmVsYXRpdmVcbiAgfSk7XG4gIGxldCBpbnRlcm5hbE9uQ2xpY2sgPSB1c2VMaW5rQ2xpY2tIYW5kbGVyKHRvLCB7XG4gICAgcmVwbGFjZSxcbiAgICBzdGF0ZSxcbiAgICB0YXJnZXQsXG4gICAgcHJldmVudFNjcm9sbFJlc2V0LFxuICAgIHJlbGF0aXZlLFxuICAgIHVuc3RhYmxlX3ZpZXdUcmFuc2l0aW9uXG4gIH0pO1xuICBmdW5jdGlvbiBoYW5kbGVDbGljayhldmVudCkge1xuICAgIGlmIChvbkNsaWNrKSBvbkNsaWNrKGV2ZW50KTtcbiAgICBpZiAoIWV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgIGludGVybmFsT25DbGljayhldmVudCk7XG4gICAgfVxuICB9XG4gIHJldHVybiAoXG4gICAgLyojX19QVVJFX18qL1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBqc3gtYTExeS9hbmNob3ItaGFzLWNvbnRlbnRcbiAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiYVwiLCBfZXh0ZW5kcyh7fSwgcmVzdCwge1xuICAgICAgaHJlZjogYWJzb2x1dGVIcmVmIHx8IGhyZWYsXG4gICAgICBvbkNsaWNrOiBpc0V4dGVybmFsIHx8IHJlbG9hZERvY3VtZW50ID8gb25DbGljayA6IGhhbmRsZUNsaWNrLFxuICAgICAgcmVmOiByZWYsXG4gICAgICB0YXJnZXQ6IHRhcmdldFxuICAgIH0pKVxuICApO1xufSk7XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIExpbmsuZGlzcGxheU5hbWUgPSBcIkxpbmtcIjtcbn1cbi8qKlxuICogQSBgPExpbms+YCB3cmFwcGVyIHRoYXQga25vd3MgaWYgaXQncyBcImFjdGl2ZVwiIG9yIG5vdC5cbiAqL1xuY29uc3QgTmF2TGluayA9IC8qI19fUFVSRV9fKi9SZWFjdC5mb3J3YXJkUmVmKGZ1bmN0aW9uIE5hdkxpbmtXaXRoUmVmKF9yZWY4LCByZWYpIHtcbiAgbGV0IHtcbiAgICAgIFwiYXJpYS1jdXJyZW50XCI6IGFyaWFDdXJyZW50UHJvcCA9IFwicGFnZVwiLFxuICAgICAgY2FzZVNlbnNpdGl2ZSA9IGZhbHNlLFxuICAgICAgY2xhc3NOYW1lOiBjbGFzc05hbWVQcm9wID0gXCJcIixcbiAgICAgIGVuZCA9IGZhbHNlLFxuICAgICAgc3R5bGU6IHN0eWxlUHJvcCxcbiAgICAgIHRvLFxuICAgICAgdW5zdGFibGVfdmlld1RyYW5zaXRpb24sXG4gICAgICBjaGlsZHJlblxuICAgIH0gPSBfcmVmOCxcbiAgICByZXN0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UoX3JlZjgsIF9leGNsdWRlZDIpO1xuICBsZXQgcGF0aCA9IHVzZVJlc29sdmVkUGF0aCh0bywge1xuICAgIHJlbGF0aXZlOiByZXN0LnJlbGF0aXZlXG4gIH0pO1xuICBsZXQgbG9jYXRpb24gPSB1c2VMb2NhdGlvbigpO1xuICBsZXQgcm91dGVyU3RhdGUgPSBSZWFjdC51c2VDb250ZXh0KFVOU0FGRV9EYXRhUm91dGVyU3RhdGVDb250ZXh0KTtcbiAgbGV0IHtcbiAgICBuYXZpZ2F0b3JcbiAgfSA9IFJlYWN0LnVzZUNvbnRleHQoVU5TQUZFX05hdmlnYXRpb25Db250ZXh0KTtcbiAgbGV0IGlzVHJhbnNpdGlvbmluZyA9IHJvdXRlclN0YXRlICE9IG51bGwgJiZcbiAgLy8gQ29uZGl0aW9uYWwgdXNhZ2UgaXMgT0sgaGVyZSBiZWNhdXNlIHRoZSB1c2FnZSBvZiBhIGRhdGEgcm91dGVyIGlzIHN0YXRpY1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvcnVsZXMtb2YtaG9va3NcbiAgdXNlVmlld1RyYW5zaXRpb25TdGF0ZShwYXRoKSAmJiB1bnN0YWJsZV92aWV3VHJhbnNpdGlvbiA9PT0gdHJ1ZTtcbiAgbGV0IHRvUGF0aG5hbWUgPSBuYXZpZ2F0b3IuZW5jb2RlTG9jYXRpb24gPyBuYXZpZ2F0b3IuZW5jb2RlTG9jYXRpb24ocGF0aCkucGF0aG5hbWUgOiBwYXRoLnBhdGhuYW1lO1xuICBsZXQgbG9jYXRpb25QYXRobmFtZSA9IGxvY2F0aW9uLnBhdGhuYW1lO1xuICBsZXQgbmV4dExvY2F0aW9uUGF0aG5hbWUgPSByb3V0ZXJTdGF0ZSAmJiByb3V0ZXJTdGF0ZS5uYXZpZ2F0aW9uICYmIHJvdXRlclN0YXRlLm5hdmlnYXRpb24ubG9jYXRpb24gPyByb3V0ZXJTdGF0ZS5uYXZpZ2F0aW9uLmxvY2F0aW9uLnBhdGhuYW1lIDogbnVsbDtcbiAgaWYgKCFjYXNlU2Vuc2l0aXZlKSB7XG4gICAgbG9jYXRpb25QYXRobmFtZSA9IGxvY2F0aW9uUGF0aG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICBuZXh0TG9jYXRpb25QYXRobmFtZSA9IG5leHRMb2NhdGlvblBhdGhuYW1lID8gbmV4dExvY2F0aW9uUGF0aG5hbWUudG9Mb3dlckNhc2UoKSA6IG51bGw7XG4gICAgdG9QYXRobmFtZSA9IHRvUGF0aG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgfVxuICAvLyBJZiB0aGUgYHRvYCBoYXMgYSB0cmFpbGluZyBzbGFzaCwgbG9vayBhdCB0aGF0IGV4YWN0IHNwb3QuICBPdGhlcndpc2UsXG4gIC8vIHdlJ3JlIGxvb2tpbmcgZm9yIGEgc2xhc2ggX2FmdGVyXyB3aGF0J3MgaW4gYHRvYC4gIEZvciBleGFtcGxlOlxuICAvL1xuICAvLyA8TmF2TGluayB0bz1cIi91c2Vyc1wiPiBhbmQgPE5hdkxpbmsgdG89XCIvdXNlcnMvXCI+XG4gIC8vIGJvdGggd2FudCB0byBsb29rIGZvciBhIC8gYXQgaW5kZXggNiB0byBtYXRjaCBVUkwgYC91c2Vycy9tYXR0YFxuICBjb25zdCBlbmRTbGFzaFBvc2l0aW9uID0gdG9QYXRobmFtZSAhPT0gXCIvXCIgJiYgdG9QYXRobmFtZS5lbmRzV2l0aChcIi9cIikgPyB0b1BhdGhuYW1lLmxlbmd0aCAtIDEgOiB0b1BhdGhuYW1lLmxlbmd0aDtcbiAgbGV0IGlzQWN0aXZlID0gbG9jYXRpb25QYXRobmFtZSA9PT0gdG9QYXRobmFtZSB8fCAhZW5kICYmIGxvY2F0aW9uUGF0aG5hbWUuc3RhcnRzV2l0aCh0b1BhdGhuYW1lKSAmJiBsb2NhdGlvblBhdGhuYW1lLmNoYXJBdChlbmRTbGFzaFBvc2l0aW9uKSA9PT0gXCIvXCI7XG4gIGxldCBpc1BlbmRpbmcgPSBuZXh0TG9jYXRpb25QYXRobmFtZSAhPSBudWxsICYmIChuZXh0TG9jYXRpb25QYXRobmFtZSA9PT0gdG9QYXRobmFtZSB8fCAhZW5kICYmIG5leHRMb2NhdGlvblBhdGhuYW1lLnN0YXJ0c1dpdGgodG9QYXRobmFtZSkgJiYgbmV4dExvY2F0aW9uUGF0aG5hbWUuY2hhckF0KHRvUGF0aG5hbWUubGVuZ3RoKSA9PT0gXCIvXCIpO1xuICBsZXQgcmVuZGVyUHJvcHMgPSB7XG4gICAgaXNBY3RpdmUsXG4gICAgaXNQZW5kaW5nLFxuICAgIGlzVHJhbnNpdGlvbmluZ1xuICB9O1xuICBsZXQgYXJpYUN1cnJlbnQgPSBpc0FjdGl2ZSA/IGFyaWFDdXJyZW50UHJvcCA6IHVuZGVmaW5lZDtcbiAgbGV0IGNsYXNzTmFtZTtcbiAgaWYgKHR5cGVvZiBjbGFzc05hbWVQcm9wID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBjbGFzc05hbWUgPSBjbGFzc05hbWVQcm9wKHJlbmRlclByb3BzKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBJZiB0aGUgY2xhc3NOYW1lIHByb3AgaXMgbm90IGEgZnVuY3Rpb24sIHdlIHVzZSBhIGRlZmF1bHQgYGFjdGl2ZWBcbiAgICAvLyBjbGFzcyBmb3IgPE5hdkxpbmsgLz5zIHRoYXQgYXJlIGFjdGl2ZS4gSW4gdjUgYGFjdGl2ZWAgd2FzIHRoZSBkZWZhdWx0XG4gICAgLy8gdmFsdWUgZm9yIGBhY3RpdmVDbGFzc05hbWVgLCBidXQgd2UgYXJlIHJlbW92aW5nIHRoYXQgQVBJIGFuZCBjYW4gc3RpbGxcbiAgICAvLyB1c2UgdGhlIG9sZCBkZWZhdWx0IGJlaGF2aW9yIGZvciBhIGNsZWFuZXIgdXBncmFkZSBwYXRoIGFuZCBrZWVwIHRoZVxuICAgIC8vIHNpbXBsZSBzdHlsaW5nIHJ1bGVzIHdvcmtpbmcgYXMgdGhleSBjdXJyZW50bHkgZG8uXG4gICAgY2xhc3NOYW1lID0gW2NsYXNzTmFtZVByb3AsIGlzQWN0aXZlID8gXCJhY3RpdmVcIiA6IG51bGwsIGlzUGVuZGluZyA/IFwicGVuZGluZ1wiIDogbnVsbCwgaXNUcmFuc2l0aW9uaW5nID8gXCJ0cmFuc2l0aW9uaW5nXCIgOiBudWxsXS5maWx0ZXIoQm9vbGVhbikuam9pbihcIiBcIik7XG4gIH1cbiAgbGV0IHN0eWxlID0gdHlwZW9mIHN0eWxlUHJvcCA9PT0gXCJmdW5jdGlvblwiID8gc3R5bGVQcm9wKHJlbmRlclByb3BzKSA6IHN0eWxlUHJvcDtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KExpbmssIF9leHRlbmRzKHt9LCByZXN0LCB7XG4gICAgXCJhcmlhLWN1cnJlbnRcIjogYXJpYUN1cnJlbnQsXG4gICAgY2xhc3NOYW1lOiBjbGFzc05hbWUsXG4gICAgcmVmOiByZWYsXG4gICAgc3R5bGU6IHN0eWxlLFxuICAgIHRvOiB0byxcbiAgICB1bnN0YWJsZV92aWV3VHJhbnNpdGlvbjogdW5zdGFibGVfdmlld1RyYW5zaXRpb25cbiAgfSksIHR5cGVvZiBjaGlsZHJlbiA9PT0gXCJmdW5jdGlvblwiID8gY2hpbGRyZW4ocmVuZGVyUHJvcHMpIDogY2hpbGRyZW4pO1xufSk7XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIE5hdkxpbmsuZGlzcGxheU5hbWUgPSBcIk5hdkxpbmtcIjtcbn1cbi8qKlxuICogQSBgQHJlbWl4LXJ1bi9yb3V0ZXJgLWF3YXJlIGA8Zm9ybT5gLiBJdCBiZWhhdmVzIGxpa2UgYSBub3JtYWwgZm9ybSBleGNlcHRcbiAqIHRoYXQgdGhlIGludGVyYWN0aW9uIHdpdGggdGhlIHNlcnZlciBpcyB3aXRoIGBmZXRjaGAgaW5zdGVhZCBvZiBuZXcgZG9jdW1lbnRcbiAqIHJlcXVlc3RzLCBhbGxvd2luZyBjb21wb25lbnRzIHRvIGFkZCBuaWNlciBVWCB0byB0aGUgcGFnZSBhcyB0aGUgZm9ybSBpc1xuICogc3VibWl0dGVkIGFuZCByZXR1cm5zIHdpdGggZGF0YS5cbiAqL1xuY29uc3QgRm9ybSA9IC8qI19fUFVSRV9fKi9SZWFjdC5mb3J3YXJkUmVmKChfcmVmOSwgZm9yd2FyZGVkUmVmKSA9PiB7XG4gIGxldCB7XG4gICAgICBmZXRjaGVyS2V5LFxuICAgICAgbmF2aWdhdGUsXG4gICAgICByZWxvYWREb2N1bWVudCxcbiAgICAgIHJlcGxhY2UsXG4gICAgICBzdGF0ZSxcbiAgICAgIG1ldGhvZCA9IGRlZmF1bHRNZXRob2QsXG4gICAgICBhY3Rpb24sXG4gICAgICBvblN1Ym1pdCxcbiAgICAgIHJlbGF0aXZlLFxuICAgICAgcHJldmVudFNjcm9sbFJlc2V0LFxuICAgICAgdW5zdGFibGVfdmlld1RyYW5zaXRpb25cbiAgICB9ID0gX3JlZjksXG4gICAgcHJvcHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShfcmVmOSwgX2V4Y2x1ZGVkMyk7XG4gIGxldCBzdWJtaXQgPSB1c2VTdWJtaXQoKTtcbiAgbGV0IGZvcm1BY3Rpb24gPSB1c2VGb3JtQWN0aW9uKGFjdGlvbiwge1xuICAgIHJlbGF0aXZlXG4gIH0pO1xuICBsZXQgZm9ybU1ldGhvZCA9IG1ldGhvZC50b0xvd2VyQ2FzZSgpID09PSBcImdldFwiID8gXCJnZXRcIiA6IFwicG9zdFwiO1xuICBsZXQgc3VibWl0SGFuZGxlciA9IGV2ZW50ID0+IHtcbiAgICBvblN1Ym1pdCAmJiBvblN1Ym1pdChldmVudCk7XG4gICAgaWYgKGV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHJldHVybjtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGxldCBzdWJtaXR0ZXIgPSBldmVudC5uYXRpdmVFdmVudC5zdWJtaXR0ZXI7XG4gICAgbGV0IHN1Ym1pdE1ldGhvZCA9IChzdWJtaXR0ZXIgPT0gbnVsbCA/IHZvaWQgMCA6IHN1Ym1pdHRlci5nZXRBdHRyaWJ1dGUoXCJmb3JtbWV0aG9kXCIpKSB8fCBtZXRob2Q7XG4gICAgc3VibWl0KHN1Ym1pdHRlciB8fCBldmVudC5jdXJyZW50VGFyZ2V0LCB7XG4gICAgICBmZXRjaGVyS2V5LFxuICAgICAgbWV0aG9kOiBzdWJtaXRNZXRob2QsXG4gICAgICBuYXZpZ2F0ZSxcbiAgICAgIHJlcGxhY2UsXG4gICAgICBzdGF0ZSxcbiAgICAgIHJlbGF0aXZlLFxuICAgICAgcHJldmVudFNjcm9sbFJlc2V0LFxuICAgICAgdW5zdGFibGVfdmlld1RyYW5zaXRpb25cbiAgICB9KTtcbiAgfTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiZm9ybVwiLCBfZXh0ZW5kcyh7XG4gICAgcmVmOiBmb3J3YXJkZWRSZWYsXG4gICAgbWV0aG9kOiBmb3JtTWV0aG9kLFxuICAgIGFjdGlvbjogZm9ybUFjdGlvbixcbiAgICBvblN1Ym1pdDogcmVsb2FkRG9jdW1lbnQgPyBvblN1Ym1pdCA6IHN1Ym1pdEhhbmRsZXJcbiAgfSwgcHJvcHMpKTtcbn0pO1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICBGb3JtLmRpc3BsYXlOYW1lID0gXCJGb3JtXCI7XG59XG4vKipcbiAqIFRoaXMgY29tcG9uZW50IHdpbGwgZW11bGF0ZSB0aGUgYnJvd3NlcidzIHNjcm9sbCByZXN0b3JhdGlvbiBvbiBsb2NhdGlvblxuICogY2hhbmdlcy5cbiAqL1xuZnVuY3Rpb24gU2Nyb2xsUmVzdG9yYXRpb24oX3JlZjEwKSB7XG4gIGxldCB7XG4gICAgZ2V0S2V5LFxuICAgIHN0b3JhZ2VLZXlcbiAgfSA9IF9yZWYxMDtcbiAgdXNlU2Nyb2xsUmVzdG9yYXRpb24oe1xuICAgIGdldEtleSxcbiAgICBzdG9yYWdlS2V5XG4gIH0pO1xuICByZXR1cm4gbnVsbDtcbn1cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgU2Nyb2xsUmVzdG9yYXRpb24uZGlzcGxheU5hbWUgPSBcIlNjcm9sbFJlc3RvcmF0aW9uXCI7XG59XG4vLyNlbmRyZWdpb25cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyNyZWdpb24gSG9va3Ncbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG52YXIgRGF0YVJvdXRlckhvb2s7XG4oZnVuY3Rpb24gKERhdGFSb3V0ZXJIb29rKSB7XG4gIERhdGFSb3V0ZXJIb29rW1wiVXNlU2Nyb2xsUmVzdG9yYXRpb25cIl0gPSBcInVzZVNjcm9sbFJlc3RvcmF0aW9uXCI7XG4gIERhdGFSb3V0ZXJIb29rW1wiVXNlU3VibWl0XCJdID0gXCJ1c2VTdWJtaXRcIjtcbiAgRGF0YVJvdXRlckhvb2tbXCJVc2VTdWJtaXRGZXRjaGVyXCJdID0gXCJ1c2VTdWJtaXRGZXRjaGVyXCI7XG4gIERhdGFSb3V0ZXJIb29rW1wiVXNlRmV0Y2hlclwiXSA9IFwidXNlRmV0Y2hlclwiO1xuICBEYXRhUm91dGVySG9va1tcInVzZVZpZXdUcmFuc2l0aW9uU3RhdGVcIl0gPSBcInVzZVZpZXdUcmFuc2l0aW9uU3RhdGVcIjtcbn0pKERhdGFSb3V0ZXJIb29rIHx8IChEYXRhUm91dGVySG9vayA9IHt9KSk7XG52YXIgRGF0YVJvdXRlclN0YXRlSG9vaztcbihmdW5jdGlvbiAoRGF0YVJvdXRlclN0YXRlSG9vaykge1xuICBEYXRhUm91dGVyU3RhdGVIb29rW1wiVXNlRmV0Y2hlclwiXSA9IFwidXNlRmV0Y2hlclwiO1xuICBEYXRhUm91dGVyU3RhdGVIb29rW1wiVXNlRmV0Y2hlcnNcIl0gPSBcInVzZUZldGNoZXJzXCI7XG4gIERhdGFSb3V0ZXJTdGF0ZUhvb2tbXCJVc2VTY3JvbGxSZXN0b3JhdGlvblwiXSA9IFwidXNlU2Nyb2xsUmVzdG9yYXRpb25cIjtcbn0pKERhdGFSb3V0ZXJTdGF0ZUhvb2sgfHwgKERhdGFSb3V0ZXJTdGF0ZUhvb2sgPSB7fSkpO1xuLy8gSW50ZXJuYWwgaG9va3NcbmZ1bmN0aW9uIGdldERhdGFSb3V0ZXJDb25zb2xlRXJyb3IoaG9va05hbWUpIHtcbiAgcmV0dXJuIGhvb2tOYW1lICsgXCIgbXVzdCBiZSB1c2VkIHdpdGhpbiBhIGRhdGEgcm91dGVyLiAgU2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL3JvdXRlcnMvcGlja2luZy1hLXJvdXRlci5cIjtcbn1cbmZ1bmN0aW9uIHVzZURhdGFSb3V0ZXJDb250ZXh0KGhvb2tOYW1lKSB7XG4gIGxldCBjdHggPSBSZWFjdC51c2VDb250ZXh0KFVOU0FGRV9EYXRhUm91dGVyQ29udGV4dCk7XG4gICFjdHggPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBVTlNBRkVfaW52YXJpYW50KGZhbHNlLCBnZXREYXRhUm91dGVyQ29uc29sZUVycm9yKGhvb2tOYW1lKSkgOiBVTlNBRkVfaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgcmV0dXJuIGN0eDtcbn1cbmZ1bmN0aW9uIHVzZURhdGFSb3V0ZXJTdGF0ZShob29rTmFtZSkge1xuICBsZXQgc3RhdGUgPSBSZWFjdC51c2VDb250ZXh0KFVOU0FGRV9EYXRhUm91dGVyU3RhdGVDb250ZXh0KTtcbiAgIXN0YXRlID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gVU5TQUZFX2ludmFyaWFudChmYWxzZSwgZ2V0RGF0YVJvdXRlckNvbnNvbGVFcnJvcihob29rTmFtZSkpIDogVU5TQUZFX2ludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gIHJldHVybiBzdGF0ZTtcbn1cbi8vIEV4dGVybmFsIGhvb2tzXG4vKipcbiAqIEhhbmRsZXMgdGhlIGNsaWNrIGJlaGF2aW9yIGZvciByb3V0ZXIgYDxMaW5rPmAgY29tcG9uZW50cy4gVGhpcyBpcyB1c2VmdWwgaWZcbiAqIHlvdSBuZWVkIHRvIGNyZWF0ZSBjdXN0b20gYDxMaW5rPmAgY29tcG9uZW50cyB3aXRoIHRoZSBzYW1lIGNsaWNrIGJlaGF2aW9yIHdlXG4gKiB1c2UgaW4gb3VyIGV4cG9ydGVkIGA8TGluaz5gLlxuICovXG5mdW5jdGlvbiB1c2VMaW5rQ2xpY2tIYW5kbGVyKHRvLCBfdGVtcCkge1xuICBsZXQge1xuICAgIHRhcmdldCxcbiAgICByZXBsYWNlOiByZXBsYWNlUHJvcCxcbiAgICBzdGF0ZSxcbiAgICBwcmV2ZW50U2Nyb2xsUmVzZXQsXG4gICAgcmVsYXRpdmUsXG4gICAgdW5zdGFibGVfdmlld1RyYW5zaXRpb25cbiAgfSA9IF90ZW1wID09PSB2b2lkIDAgPyB7fSA6IF90ZW1wO1xuICBsZXQgbmF2aWdhdGUgPSB1c2VOYXZpZ2F0ZSgpO1xuICBsZXQgbG9jYXRpb24gPSB1c2VMb2NhdGlvbigpO1xuICBsZXQgcGF0aCA9IHVzZVJlc29sdmVkUGF0aCh0bywge1xuICAgIHJlbGF0aXZlXG4gIH0pO1xuICByZXR1cm4gUmVhY3QudXNlQ2FsbGJhY2soZXZlbnQgPT4ge1xuICAgIGlmIChzaG91bGRQcm9jZXNzTGlua0NsaWNrKGV2ZW50LCB0YXJnZXQpKSB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgLy8gSWYgdGhlIFVSTCBoYXNuJ3QgY2hhbmdlZCwgYSByZWd1bGFyIDxhPiB3aWxsIGRvIGEgcmVwbGFjZSBpbnN0ZWFkIG9mXG4gICAgICAvLyBhIHB1c2gsIHNvIGRvIHRoZSBzYW1lIGhlcmUgdW5sZXNzIHRoZSByZXBsYWNlIHByb3AgaXMgZXhwbGljaXRseSBzZXRcbiAgICAgIGxldCByZXBsYWNlID0gcmVwbGFjZVByb3AgIT09IHVuZGVmaW5lZCA/IHJlcGxhY2VQcm9wIDogY3JlYXRlUGF0aChsb2NhdGlvbikgPT09IGNyZWF0ZVBhdGgocGF0aCk7XG4gICAgICBuYXZpZ2F0ZSh0bywge1xuICAgICAgICByZXBsYWNlLFxuICAgICAgICBzdGF0ZSxcbiAgICAgICAgcHJldmVudFNjcm9sbFJlc2V0LFxuICAgICAgICByZWxhdGl2ZSxcbiAgICAgICAgdW5zdGFibGVfdmlld1RyYW5zaXRpb25cbiAgICAgIH0pO1xuICAgIH1cbiAgfSwgW2xvY2F0aW9uLCBuYXZpZ2F0ZSwgcGF0aCwgcmVwbGFjZVByb3AsIHN0YXRlLCB0YXJnZXQsIHRvLCBwcmV2ZW50U2Nyb2xsUmVzZXQsIHJlbGF0aXZlLCB1bnN0YWJsZV92aWV3VHJhbnNpdGlvbl0pO1xufVxuLyoqXG4gKiBBIGNvbnZlbmllbnQgd3JhcHBlciBmb3IgcmVhZGluZyBhbmQgd3JpdGluZyBzZWFyY2ggcGFyYW1ldGVycyB2aWEgdGhlXG4gKiBVUkxTZWFyY2hQYXJhbXMgaW50ZXJmYWNlLlxuICovXG5mdW5jdGlvbiB1c2VTZWFyY2hQYXJhbXMoZGVmYXVsdEluaXQpIHtcbiAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gVU5TQUZFX3dhcm5pbmcodHlwZW9mIFVSTFNlYXJjaFBhcmFtcyAhPT0gXCJ1bmRlZmluZWRcIiwgXCJZb3UgY2Fubm90IHVzZSB0aGUgYHVzZVNlYXJjaFBhcmFtc2AgaG9vayBpbiBhIGJyb3dzZXIgdGhhdCBkb2VzIG5vdCBcIiArIFwic3VwcG9ydCB0aGUgVVJMU2VhcmNoUGFyYW1zIEFQSS4gSWYgeW91IG5lZWQgdG8gc3VwcG9ydCBJbnRlcm5ldCBcIiArIFwiRXhwbG9yZXIgMTEsIHdlIHJlY29tbWVuZCB5b3UgbG9hZCBhIHBvbHlmaWxsIHN1Y2ggYXMgXCIgKyBcImh0dHBzOi8vZ2l0aHViLmNvbS91bmdhcC91cmwtc2VhcmNoLXBhcmFtc1xcblxcblwiICsgXCJJZiB5b3UncmUgdW5zdXJlIGhvdyB0byBsb2FkIHBvbHlmaWxscywgd2UgcmVjb21tZW5kIHlvdSBjaGVjayBvdXQgXCIgKyBcImh0dHBzOi8vcG9seWZpbGwuaW8vdjMvIHdoaWNoIHByb3ZpZGVzIHNvbWUgcmVjb21tZW5kYXRpb25zIGFib3V0IGhvdyBcIiArIFwidG8gbG9hZCBwb2x5ZmlsbHMgb25seSBmb3IgdXNlcnMgdGhhdCBuZWVkIHRoZW0sIGluc3RlYWQgb2YgZm9yIGV2ZXJ5IFwiICsgXCJ1c2VyLlwiKSA6IHZvaWQgMDtcbiAgbGV0IGRlZmF1bHRTZWFyY2hQYXJhbXNSZWYgPSBSZWFjdC51c2VSZWYoY3JlYXRlU2VhcmNoUGFyYW1zKGRlZmF1bHRJbml0KSk7XG4gIGxldCBoYXNTZXRTZWFyY2hQYXJhbXNSZWYgPSBSZWFjdC51c2VSZWYoZmFsc2UpO1xuICBsZXQgbG9jYXRpb24gPSB1c2VMb2NhdGlvbigpO1xuICBsZXQgc2VhcmNoUGFyYW1zID0gUmVhY3QudXNlTWVtbygoKSA9PlxuICAvLyBPbmx5IG1lcmdlIGluIHRoZSBkZWZhdWx0cyBpZiB3ZSBoYXZlbid0IHlldCBjYWxsZWQgc2V0U2VhcmNoUGFyYW1zLlxuICAvLyBPbmNlIHdlIGNhbGwgdGhhdCB3ZSB3YW50IHRob3NlIHRvIHRha2UgcHJlY2VkZW5jZSwgb3RoZXJ3aXNlIHlvdSBjYW4ndFxuICAvLyByZW1vdmUgYSBwYXJhbSB3aXRoIHNldFNlYXJjaFBhcmFtcyh7fSkgaWYgaXQgaGFzIGFuIGluaXRpYWwgdmFsdWVcbiAgZ2V0U2VhcmNoUGFyYW1zRm9yTG9jYXRpb24obG9jYXRpb24uc2VhcmNoLCBoYXNTZXRTZWFyY2hQYXJhbXNSZWYuY3VycmVudCA/IG51bGwgOiBkZWZhdWx0U2VhcmNoUGFyYW1zUmVmLmN1cnJlbnQpLCBbbG9jYXRpb24uc2VhcmNoXSk7XG4gIGxldCBuYXZpZ2F0ZSA9IHVzZU5hdmlnYXRlKCk7XG4gIGxldCBzZXRTZWFyY2hQYXJhbXMgPSBSZWFjdC51c2VDYWxsYmFjaygobmV4dEluaXQsIG5hdmlnYXRlT3B0aW9ucykgPT4ge1xuICAgIGNvbnN0IG5ld1NlYXJjaFBhcmFtcyA9IGNyZWF0ZVNlYXJjaFBhcmFtcyh0eXBlb2YgbmV4dEluaXQgPT09IFwiZnVuY3Rpb25cIiA/IG5leHRJbml0KHNlYXJjaFBhcmFtcykgOiBuZXh0SW5pdCk7XG4gICAgaGFzU2V0U2VhcmNoUGFyYW1zUmVmLmN1cnJlbnQgPSB0cnVlO1xuICAgIG5hdmlnYXRlKFwiP1wiICsgbmV3U2VhcmNoUGFyYW1zLCBuYXZpZ2F0ZU9wdGlvbnMpO1xuICB9LCBbbmF2aWdhdGUsIHNlYXJjaFBhcmFtc10pO1xuICByZXR1cm4gW3NlYXJjaFBhcmFtcywgc2V0U2VhcmNoUGFyYW1zXTtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlQ2xpZW50U2lkZVN1Ym1pc3Npb24oKSB7XG4gIGlmICh0eXBlb2YgZG9jdW1lbnQgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJZb3UgYXJlIGNhbGxpbmcgc3VibWl0IGR1cmluZyB0aGUgc2VydmVyIHJlbmRlci4gXCIgKyBcIlRyeSBjYWxsaW5nIHN1Ym1pdCB3aXRoaW4gYSBgdXNlRWZmZWN0YCBvciBjYWxsYmFjayBpbnN0ZWFkLlwiKTtcbiAgfVxufVxubGV0IGZldGNoZXJJZCA9IDA7XG5sZXQgZ2V0VW5pcXVlRmV0Y2hlcklkID0gKCkgPT4gXCJfX1wiICsgU3RyaW5nKCsrZmV0Y2hlcklkKSArIFwiX19cIjtcbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgbWF5IGJlIHVzZWQgdG8gcHJvZ3JhbW1hdGljYWxseSBzdWJtaXQgYSBmb3JtIChvclxuICogc29tZSBhcmJpdHJhcnkgZGF0YSkgdG8gdGhlIHNlcnZlci5cbiAqL1xuZnVuY3Rpb24gdXNlU3VibWl0KCkge1xuICBsZXQge1xuICAgIHJvdXRlclxuICB9ID0gdXNlRGF0YVJvdXRlckNvbnRleHQoRGF0YVJvdXRlckhvb2suVXNlU3VibWl0KTtcbiAgbGV0IHtcbiAgICBiYXNlbmFtZVxuICB9ID0gUmVhY3QudXNlQ29udGV4dChVTlNBRkVfTmF2aWdhdGlvbkNvbnRleHQpO1xuICBsZXQgY3VycmVudFJvdXRlSWQgPSBVTlNBRkVfdXNlUm91dGVJZCgpO1xuICByZXR1cm4gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKHRhcmdldCwgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG4gICAgdmFsaWRhdGVDbGllbnRTaWRlU3VibWlzc2lvbigpO1xuICAgIGxldCB7XG4gICAgICBhY3Rpb24sXG4gICAgICBtZXRob2QsXG4gICAgICBlbmNUeXBlLFxuICAgICAgZm9ybURhdGEsXG4gICAgICBib2R5XG4gICAgfSA9IGdldEZvcm1TdWJtaXNzaW9uSW5mbyh0YXJnZXQsIGJhc2VuYW1lKTtcbiAgICBpZiAob3B0aW9ucy5uYXZpZ2F0ZSA9PT0gZmFsc2UpIHtcbiAgICAgIGxldCBrZXkgPSBvcHRpb25zLmZldGNoZXJLZXkgfHwgZ2V0VW5pcXVlRmV0Y2hlcklkKCk7XG4gICAgICByb3V0ZXIuZmV0Y2goa2V5LCBjdXJyZW50Um91dGVJZCwgb3B0aW9ucy5hY3Rpb24gfHwgYWN0aW9uLCB7XG4gICAgICAgIHByZXZlbnRTY3JvbGxSZXNldDogb3B0aW9ucy5wcmV2ZW50U2Nyb2xsUmVzZXQsXG4gICAgICAgIGZvcm1EYXRhLFxuICAgICAgICBib2R5LFxuICAgICAgICBmb3JtTWV0aG9kOiBvcHRpb25zLm1ldGhvZCB8fCBtZXRob2QsXG4gICAgICAgIGZvcm1FbmNUeXBlOiBvcHRpb25zLmVuY1R5cGUgfHwgZW5jVHlwZSxcbiAgICAgICAgdW5zdGFibGVfZmx1c2hTeW5jOiBvcHRpb25zLnVuc3RhYmxlX2ZsdXNoU3luY1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJvdXRlci5uYXZpZ2F0ZShvcHRpb25zLmFjdGlvbiB8fCBhY3Rpb24sIHtcbiAgICAgICAgcHJldmVudFNjcm9sbFJlc2V0OiBvcHRpb25zLnByZXZlbnRTY3JvbGxSZXNldCxcbiAgICAgICAgZm9ybURhdGEsXG4gICAgICAgIGJvZHksXG4gICAgICAgIGZvcm1NZXRob2Q6IG9wdGlvbnMubWV0aG9kIHx8IG1ldGhvZCxcbiAgICAgICAgZm9ybUVuY1R5cGU6IG9wdGlvbnMuZW5jVHlwZSB8fCBlbmNUeXBlLFxuICAgICAgICByZXBsYWNlOiBvcHRpb25zLnJlcGxhY2UsXG4gICAgICAgIHN0YXRlOiBvcHRpb25zLnN0YXRlLFxuICAgICAgICBmcm9tUm91dGVJZDogY3VycmVudFJvdXRlSWQsXG4gICAgICAgIHVuc3RhYmxlX2ZsdXNoU3luYzogb3B0aW9ucy51bnN0YWJsZV9mbHVzaFN5bmMsXG4gICAgICAgIHVuc3RhYmxlX3ZpZXdUcmFuc2l0aW9uOiBvcHRpb25zLnVuc3RhYmxlX3ZpZXdUcmFuc2l0aW9uXG4gICAgICB9KTtcbiAgICB9XG4gIH0sIFtyb3V0ZXIsIGJhc2VuYW1lLCBjdXJyZW50Um91dGVJZF0pO1xufVxuLy8gdjc6IEV2ZW50dWFsbHkgd2Ugc2hvdWxkIGRlcHJlY2F0ZSB0aGlzIGVudGlyZWx5IGluIGZhdm9yIG9mIHVzaW5nIHRoZVxuLy8gcm91dGVyIG1ldGhvZCBkaXJlY3RseT9cbmZ1bmN0aW9uIHVzZUZvcm1BY3Rpb24oYWN0aW9uLCBfdGVtcDIpIHtcbiAgbGV0IHtcbiAgICByZWxhdGl2ZVxuICB9ID0gX3RlbXAyID09PSB2b2lkIDAgPyB7fSA6IF90ZW1wMjtcbiAgbGV0IHtcbiAgICBiYXNlbmFtZVxuICB9ID0gUmVhY3QudXNlQ29udGV4dChVTlNBRkVfTmF2aWdhdGlvbkNvbnRleHQpO1xuICBsZXQgcm91dGVDb250ZXh0ID0gUmVhY3QudXNlQ29udGV4dChVTlNBRkVfUm91dGVDb250ZXh0KTtcbiAgIXJvdXRlQ29udGV4dCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IFVOU0FGRV9pbnZhcmlhbnQoZmFsc2UsIFwidXNlRm9ybUFjdGlvbiBtdXN0IGJlIHVzZWQgaW5zaWRlIGEgUm91dGVDb250ZXh0XCIpIDogVU5TQUZFX2ludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gIGxldCBbbWF0Y2hdID0gcm91dGVDb250ZXh0Lm1hdGNoZXMuc2xpY2UoLTEpO1xuICAvLyBTaGFsbG93IGNsb25lIHBhdGggc28gd2UgY2FuIG1vZGlmeSBpdCBiZWxvdywgb3RoZXJ3aXNlIHdlIG1vZGlmeSB0aGVcbiAgLy8gb2JqZWN0IHJlZmVyZW5jZWQgYnkgdXNlTWVtbyBpbnNpZGUgdXNlUmVzb2x2ZWRQYXRoXG4gIGxldCBwYXRoID0gX2V4dGVuZHMoe30sIHVzZVJlc29sdmVkUGF0aChhY3Rpb24gPyBhY3Rpb24gOiBcIi5cIiwge1xuICAgIHJlbGF0aXZlXG4gIH0pKTtcbiAgLy8gSWYgbm8gYWN0aW9uIHdhcyBzcGVjaWZpZWQsIGJyb3dzZXJzIHdpbGwgcGVyc2lzdCBjdXJyZW50IHNlYXJjaCBwYXJhbXNcbiAgLy8gd2hlbiBkZXRlcm1pbmluZyB0aGUgcGF0aCwgc28gbWF0Y2ggdGhhdCBiZWhhdmlvclxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vcmVtaXgtcnVuL3JlbWl4L2lzc3Vlcy85MjdcbiAgbGV0IGxvY2F0aW9uID0gdXNlTG9jYXRpb24oKTtcbiAgaWYgKGFjdGlvbiA9PSBudWxsKSB7XG4gICAgLy8gU2FmZSB0byB3cml0ZSB0byB0aGlzIGRpcmVjdGx5IGhlcmUgc2luY2UgaWYgYWN0aW9uIHdhcyB1bmRlZmluZWQsIHdlXG4gICAgLy8gd291bGQgaGF2ZSBjYWxsZWQgdXNlUmVzb2x2ZWRQYXRoKFwiLlwiKSB3aGljaCB3aWxsIG5ldmVyIGluY2x1ZGUgYSBzZWFyY2hcbiAgICBwYXRoLnNlYXJjaCA9IGxvY2F0aW9uLnNlYXJjaDtcbiAgICAvLyBXaGVuIGdyYWJiaW5nIHNlYXJjaCBwYXJhbXMgZnJvbSB0aGUgVVJMLCByZW1vdmUgYW55IGluY2x1ZGVkID9pbmRleCBwYXJhbVxuICAgIC8vIHNpbmNlIGl0IG1pZ2h0IG5vdCBhcHBseSB0byBvdXIgY29udGV4dHVhbCByb3V0ZS4gIFdlIGFkZCBpdCBiYWNrIGJhc2VkXG4gICAgLy8gb24gbWF0Y2gucm91dGUuaW5kZXggYmVsb3dcbiAgICBsZXQgcGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcyhwYXRoLnNlYXJjaCk7XG4gICAgaWYgKHBhcmFtcy5oYXMoXCJpbmRleFwiKSAmJiBwYXJhbXMuZ2V0KFwiaW5kZXhcIikgPT09IFwiXCIpIHtcbiAgICAgIHBhcmFtcy5kZWxldGUoXCJpbmRleFwiKTtcbiAgICAgIHBhdGguc2VhcmNoID0gcGFyYW1zLnRvU3RyaW5nKCkgPyBcIj9cIiArIHBhcmFtcy50b1N0cmluZygpIDogXCJcIjtcbiAgICB9XG4gIH1cbiAgaWYgKCghYWN0aW9uIHx8IGFjdGlvbiA9PT0gXCIuXCIpICYmIG1hdGNoLnJvdXRlLmluZGV4KSB7XG4gICAgcGF0aC5zZWFyY2ggPSBwYXRoLnNlYXJjaCA/IHBhdGguc2VhcmNoLnJlcGxhY2UoL15cXD8vLCBcIj9pbmRleCZcIikgOiBcIj9pbmRleFwiO1xuICB9XG4gIC8vIElmIHdlJ3JlIG9wZXJhdGluZyB3aXRoaW4gYSBiYXNlbmFtZSwgcHJlcGVuZCBpdCB0byB0aGUgcGF0aG5hbWUgcHJpb3JcbiAgLy8gdG8gY3JlYXRpbmcgdGhlIGZvcm0gYWN0aW9uLiAgSWYgdGhpcyBpcyBhIHJvb3QgbmF2aWdhdGlvbiwgdGhlbiBqdXN0IHVzZVxuICAvLyB0aGUgcmF3IGJhc2VuYW1lIHdoaWNoIGFsbG93cyB0aGUgYmFzZW5hbWUgdG8gaGF2ZSBmdWxsIGNvbnRyb2wgb3ZlciB0aGVcbiAgLy8gcHJlc2VuY2Ugb2YgYSB0cmFpbGluZyBzbGFzaCBvbiByb290IGFjdGlvbnNcbiAgaWYgKGJhc2VuYW1lICE9PSBcIi9cIikge1xuICAgIHBhdGgucGF0aG5hbWUgPSBwYXRoLnBhdGhuYW1lID09PSBcIi9cIiA/IGJhc2VuYW1lIDogam9pblBhdGhzKFtiYXNlbmFtZSwgcGF0aC5wYXRobmFtZV0pO1xuICB9XG4gIHJldHVybiBjcmVhdGVQYXRoKHBhdGgpO1xufVxuLy8gVE9ETzogKHY3KSBDaGFuZ2UgdGhlIHVzZUZldGNoZXIgZ2VuZXJpYyBkZWZhdWx0IGZyb20gYGFueWAgdG8gYHVua25vd25gXG4vKipcbiAqIEludGVyYWN0cyB3aXRoIHJvdXRlIGxvYWRlcnMgYW5kIGFjdGlvbnMgd2l0aG91dCBjYXVzaW5nIGEgbmF2aWdhdGlvbi4gR3JlYXRcbiAqIGZvciBhbnkgaW50ZXJhY3Rpb24gdGhhdCBzdGF5cyBvbiB0aGUgc2FtZSBwYWdlLlxuICovXG5mdW5jdGlvbiB1c2VGZXRjaGVyKF90ZW1wMykge1xuICB2YXIgX3JvdXRlJG1hdGNoZXM7XG4gIGxldCB7XG4gICAga2V5XG4gIH0gPSBfdGVtcDMgPT09IHZvaWQgMCA/IHt9IDogX3RlbXAzO1xuICBsZXQge1xuICAgIHJvdXRlclxuICB9ID0gdXNlRGF0YVJvdXRlckNvbnRleHQoRGF0YVJvdXRlckhvb2suVXNlRmV0Y2hlcik7XG4gIGxldCBzdGF0ZSA9IHVzZURhdGFSb3V0ZXJTdGF0ZShEYXRhUm91dGVyU3RhdGVIb29rLlVzZUZldGNoZXIpO1xuICBsZXQgZmV0Y2hlckRhdGEgPSBSZWFjdC51c2VDb250ZXh0KEZldGNoZXJzQ29udGV4dCk7XG4gIGxldCByb3V0ZSA9IFJlYWN0LnVzZUNvbnRleHQoVU5TQUZFX1JvdXRlQ29udGV4dCk7XG4gIGxldCByb3V0ZUlkID0gKF9yb3V0ZSRtYXRjaGVzID0gcm91dGUubWF0Y2hlc1tyb3V0ZS5tYXRjaGVzLmxlbmd0aCAtIDFdKSA9PSBudWxsID8gdm9pZCAwIDogX3JvdXRlJG1hdGNoZXMucm91dGUuaWQ7XG4gICFmZXRjaGVyRGF0YSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IFVOU0FGRV9pbnZhcmlhbnQoZmFsc2UsIFwidXNlRmV0Y2hlciBtdXN0IGJlIHVzZWQgaW5zaWRlIGEgRmV0Y2hlcnNDb250ZXh0XCIpIDogVU5TQUZFX2ludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICFyb3V0ZSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IFVOU0FGRV9pbnZhcmlhbnQoZmFsc2UsIFwidXNlRmV0Y2hlciBtdXN0IGJlIHVzZWQgaW5zaWRlIGEgUm91dGVDb250ZXh0XCIpIDogVU5TQUZFX2ludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICEocm91dGVJZCAhPSBudWxsKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IFVOU0FGRV9pbnZhcmlhbnQoZmFsc2UsIFwidXNlRmV0Y2hlciBjYW4gb25seSBiZSB1c2VkIG9uIHJvdXRlcyB0aGF0IGNvbnRhaW4gYSB1bmlxdWUgXFxcImlkXFxcIlwiKSA6IFVOU0FGRV9pbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAvLyBGZXRjaGVyIGtleSBoYW5kbGluZ1xuICBsZXQgW2ZldGNoZXJLZXksIHNldEZldGNoZXJLZXldID0gUmVhY3QudXNlU3RhdGUoa2V5IHx8IFwiXCIpO1xuICBpZiAoa2V5ICYmIGtleSAhPT0gZmV0Y2hlcktleSkge1xuICAgIHNldEZldGNoZXJLZXkoa2V5KTtcbiAgfSBlbHNlIGlmICghZmV0Y2hlcktleSkge1xuICAgIHNldEZldGNoZXJLZXkoZ2V0VW5pcXVlRmV0Y2hlcklkKCkpO1xuICB9XG4gIC8vIFJlZ2lzdHJhdGlvbi9jbGVhbnVwXG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgcm91dGVyLmdldEZldGNoZXIoZmV0Y2hlcktleSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIC8vIFRlbGwgdGhlIHJvdXRlciB3ZSd2ZSB1bm1vdW50ZWQgLSBpZiB2N19mZXRjaGVyUGVyc2lzdCBpcyBlbmFibGVkIHRoaXNcbiAgICAgIC8vIHdpbGwgbm90IGRlbGV0ZSBpbW1lZGlhdGVseSBidXQgaW5zdGVhZCBxdWV1ZSB1cCBhIGRlbGV0ZSBhZnRlciB0aGVcbiAgICAgIC8vIGZldGNoZXIgcmV0dXJucyB0byBhbiBgaWRsZWAgc3RhdGVcbiAgICAgIHJvdXRlci5kZWxldGVGZXRjaGVyKGZldGNoZXJLZXkpO1xuICAgIH07XG4gIH0sIFtyb3V0ZXIsIGZldGNoZXJLZXldKTtcbiAgLy8gRmV0Y2hlciBhZGRpdGlvbnNcbiAgbGV0IGxvYWQgPSBSZWFjdC51c2VDYWxsYmFjaygoaHJlZiwgb3B0cykgPT4ge1xuICAgICFyb3V0ZUlkID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gVU5TQUZFX2ludmFyaWFudChmYWxzZSwgXCJObyByb3V0ZUlkIGF2YWlsYWJsZSBmb3IgZmV0Y2hlci5sb2FkKClcIikgOiBVTlNBRkVfaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICByb3V0ZXIuZmV0Y2goZmV0Y2hlcktleSwgcm91dGVJZCwgaHJlZiwgb3B0cyk7XG4gIH0sIFtmZXRjaGVyS2V5LCByb3V0ZUlkLCByb3V0ZXJdKTtcbiAgbGV0IHN1Ym1pdEltcGwgPSB1c2VTdWJtaXQoKTtcbiAgbGV0IHN1Ym1pdCA9IFJlYWN0LnVzZUNhbGxiYWNrKCh0YXJnZXQsIG9wdHMpID0+IHtcbiAgICBzdWJtaXRJbXBsKHRhcmdldCwgX2V4dGVuZHMoe30sIG9wdHMsIHtcbiAgICAgIG5hdmlnYXRlOiBmYWxzZSxcbiAgICAgIGZldGNoZXJLZXlcbiAgICB9KSk7XG4gIH0sIFtmZXRjaGVyS2V5LCBzdWJtaXRJbXBsXSk7XG4gIGxldCBGZXRjaGVyRm9ybSA9IFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgIGxldCBGZXRjaGVyRm9ybSA9IC8qI19fUFVSRV9fKi9SZWFjdC5mb3J3YXJkUmVmKChwcm9wcywgcmVmKSA9PiB7XG4gICAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoRm9ybSwgX2V4dGVuZHMoe30sIHByb3BzLCB7XG4gICAgICAgIG5hdmlnYXRlOiBmYWxzZSxcbiAgICAgICAgZmV0Y2hlcktleTogZmV0Y2hlcktleSxcbiAgICAgICAgcmVmOiByZWZcbiAgICAgIH0pKTtcbiAgICB9KTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICBGZXRjaGVyRm9ybS5kaXNwbGF5TmFtZSA9IFwiZmV0Y2hlci5Gb3JtXCI7XG4gICAgfVxuICAgIHJldHVybiBGZXRjaGVyRm9ybTtcbiAgfSwgW2ZldGNoZXJLZXldKTtcbiAgLy8gRXhwb3NlZCBGZXRjaGVyV2l0aENvbXBvbmVudHNcbiAgbGV0IGZldGNoZXIgPSBzdGF0ZS5mZXRjaGVycy5nZXQoZmV0Y2hlcktleSkgfHwgSURMRV9GRVRDSEVSO1xuICBsZXQgZGF0YSA9IGZldGNoZXJEYXRhLmdldChmZXRjaGVyS2V5KTtcbiAgbGV0IGZldGNoZXJXaXRoQ29tcG9uZW50cyA9IFJlYWN0LnVzZU1lbW8oKCkgPT4gX2V4dGVuZHMoe1xuICAgIEZvcm06IEZldGNoZXJGb3JtLFxuICAgIHN1Ym1pdCxcbiAgICBsb2FkXG4gIH0sIGZldGNoZXIsIHtcbiAgICBkYXRhXG4gIH0pLCBbRmV0Y2hlckZvcm0sIHN1Ym1pdCwgbG9hZCwgZmV0Y2hlciwgZGF0YV0pO1xuICByZXR1cm4gZmV0Y2hlcldpdGhDb21wb25lbnRzO1xufVxuLyoqXG4gKiBQcm92aWRlcyBhbGwgZmV0Y2hlcnMgY3VycmVudGx5IG9uIHRoZSBwYWdlLiBVc2VmdWwgZm9yIGxheW91dHMgYW5kIHBhcmVudFxuICogcm91dGVzIHRoYXQgbmVlZCB0byBwcm92aWRlIHBlbmRpbmcvb3B0aW1pc3RpYyBVSSByZWdhcmRpbmcgdGhlIGZldGNoLlxuICovXG5mdW5jdGlvbiB1c2VGZXRjaGVycygpIHtcbiAgbGV0IHN0YXRlID0gdXNlRGF0YVJvdXRlclN0YXRlKERhdGFSb3V0ZXJTdGF0ZUhvb2suVXNlRmV0Y2hlcnMpO1xuICByZXR1cm4gQXJyYXkuZnJvbShzdGF0ZS5mZXRjaGVycy5lbnRyaWVzKCkpLm1hcChfcmVmMTEgPT4ge1xuICAgIGxldCBba2V5LCBmZXRjaGVyXSA9IF9yZWYxMTtcbiAgICByZXR1cm4gX2V4dGVuZHMoe30sIGZldGNoZXIsIHtcbiAgICAgIGtleVxuICAgIH0pO1xuICB9KTtcbn1cbmNvbnN0IFNDUk9MTF9SRVNUT1JBVElPTl9TVE9SQUdFX0tFWSA9IFwicmVhY3Qtcm91dGVyLXNjcm9sbC1wb3NpdGlvbnNcIjtcbmxldCBzYXZlZFNjcm9sbFBvc2l0aW9ucyA9IHt9O1xuLyoqXG4gKiBXaGVuIHJlbmRlcmVkIGluc2lkZSBhIFJvdXRlclByb3ZpZGVyLCB3aWxsIHJlc3RvcmUgc2Nyb2xsIHBvc2l0aW9ucyBvbiBuYXZpZ2F0aW9uc1xuICovXG5mdW5jdGlvbiB1c2VTY3JvbGxSZXN0b3JhdGlvbihfdGVtcDQpIHtcbiAgbGV0IHtcbiAgICBnZXRLZXksXG4gICAgc3RvcmFnZUtleVxuICB9ID0gX3RlbXA0ID09PSB2b2lkIDAgPyB7fSA6IF90ZW1wNDtcbiAgbGV0IHtcbiAgICByb3V0ZXJcbiAgfSA9IHVzZURhdGFSb3V0ZXJDb250ZXh0KERhdGFSb3V0ZXJIb29rLlVzZVNjcm9sbFJlc3RvcmF0aW9uKTtcbiAgbGV0IHtcbiAgICByZXN0b3JlU2Nyb2xsUG9zaXRpb24sXG4gICAgcHJldmVudFNjcm9sbFJlc2V0XG4gIH0gPSB1c2VEYXRhUm91dGVyU3RhdGUoRGF0YVJvdXRlclN0YXRlSG9vay5Vc2VTY3JvbGxSZXN0b3JhdGlvbik7XG4gIGxldCB7XG4gICAgYmFzZW5hbWVcbiAgfSA9IFJlYWN0LnVzZUNvbnRleHQoVU5TQUZFX05hdmlnYXRpb25Db250ZXh0KTtcbiAgbGV0IGxvY2F0aW9uID0gdXNlTG9jYXRpb24oKTtcbiAgbGV0IG1hdGNoZXMgPSB1c2VNYXRjaGVzKCk7XG4gIGxldCBuYXZpZ2F0aW9uID0gdXNlTmF2aWdhdGlvbigpO1xuICAvLyBUcmlnZ2VyIG1hbnVhbCBzY3JvbGwgcmVzdG9yYXRpb24gd2hpbGUgd2UncmUgYWN0aXZlXG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgd2luZG93Lmhpc3Rvcnkuc2Nyb2xsUmVzdG9yYXRpb24gPSBcIm1hbnVhbFwiO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICB3aW5kb3cuaGlzdG9yeS5zY3JvbGxSZXN0b3JhdGlvbiA9IFwiYXV0b1wiO1xuICAgIH07XG4gIH0sIFtdKTtcbiAgLy8gU2F2ZSBwb3NpdGlvbnMgb24gcGFnZWhpZGVcbiAgdXNlUGFnZUhpZGUoUmVhY3QudXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIGlmIChuYXZpZ2F0aW9uLnN0YXRlID09PSBcImlkbGVcIikge1xuICAgICAgbGV0IGtleSA9IChnZXRLZXkgPyBnZXRLZXkobG9jYXRpb24sIG1hdGNoZXMpIDogbnVsbCkgfHwgbG9jYXRpb24ua2V5O1xuICAgICAgc2F2ZWRTY3JvbGxQb3NpdGlvbnNba2V5XSA9IHdpbmRvdy5zY3JvbGxZO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgc2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbShzdG9yYWdlS2V5IHx8IFNDUk9MTF9SRVNUT1JBVElPTl9TVE9SQUdFX0tFWSwgSlNPTi5zdHJpbmdpZnkoc2F2ZWRTY3JvbGxQb3NpdGlvbnMpKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gVU5TQUZFX3dhcm5pbmcoZmFsc2UsIFwiRmFpbGVkIHRvIHNhdmUgc2Nyb2xsIHBvc2l0aW9ucyBpbiBzZXNzaW9uU3RvcmFnZSwgPFNjcm9sbFJlc3RvcmF0aW9uIC8+IHdpbGwgbm90IHdvcmsgcHJvcGVybHkgKFwiICsgZXJyb3IgKyBcIikuXCIpIDogdm9pZCAwO1xuICAgIH1cbiAgICB3aW5kb3cuaGlzdG9yeS5zY3JvbGxSZXN0b3JhdGlvbiA9IFwiYXV0b1wiO1xuICB9LCBbc3RvcmFnZUtleSwgZ2V0S2V5LCBuYXZpZ2F0aW9uLnN0YXRlLCBsb2NhdGlvbiwgbWF0Y2hlc10pKTtcbiAgLy8gUmVhZCBpbiBhbnkgc2F2ZWQgc2Nyb2xsIGxvY2F0aW9uc1xuICBpZiAodHlwZW9mIGRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL3J1bGVzLW9mLWhvb2tzXG4gICAgUmVhY3QudXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGxldCBzZXNzaW9uUG9zaXRpb25zID0gc2Vzc2lvblN0b3JhZ2UuZ2V0SXRlbShzdG9yYWdlS2V5IHx8IFNDUk9MTF9SRVNUT1JBVElPTl9TVE9SQUdFX0tFWSk7XG4gICAgICAgIGlmIChzZXNzaW9uUG9zaXRpb25zKSB7XG4gICAgICAgICAgc2F2ZWRTY3JvbGxQb3NpdGlvbnMgPSBKU09OLnBhcnNlKHNlc3Npb25Qb3NpdGlvbnMpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8vIG5vLW9wLCB1c2UgZGVmYXVsdCBlbXB0eSBvYmplY3RcbiAgICAgIH1cbiAgICB9LCBbc3RvcmFnZUtleV0pO1xuICAgIC8vIEVuYWJsZSBzY3JvbGwgcmVzdG9yYXRpb24gaW4gdGhlIHJvdXRlclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9ydWxlcy1vZi1ob29rc1xuICAgIFJlYWN0LnVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgICBsZXQgZ2V0S2V5V2l0aG91dEJhc2VuYW1lID0gZ2V0S2V5ICYmIGJhc2VuYW1lICE9PSBcIi9cIiA/IChsb2NhdGlvbiwgbWF0Y2hlcykgPT4gZ2V0S2V5KCAvLyBTdHJpcCB0aGUgYmFzZW5hbWUgdG8gbWF0Y2ggdXNlTG9jYXRpb24oKVxuICAgICAgX2V4dGVuZHMoe30sIGxvY2F0aW9uLCB7XG4gICAgICAgIHBhdGhuYW1lOiBzdHJpcEJhc2VuYW1lKGxvY2F0aW9uLnBhdGhuYW1lLCBiYXNlbmFtZSkgfHwgbG9jYXRpb24ucGF0aG5hbWVcbiAgICAgIH0pLCBtYXRjaGVzKSA6IGdldEtleTtcbiAgICAgIGxldCBkaXNhYmxlU2Nyb2xsUmVzdG9yYXRpb24gPSByb3V0ZXIgPT0gbnVsbCA/IHZvaWQgMCA6IHJvdXRlci5lbmFibGVTY3JvbGxSZXN0b3JhdGlvbihzYXZlZFNjcm9sbFBvc2l0aW9ucywgKCkgPT4gd2luZG93LnNjcm9sbFksIGdldEtleVdpdGhvdXRCYXNlbmFtZSk7XG4gICAgICByZXR1cm4gKCkgPT4gZGlzYWJsZVNjcm9sbFJlc3RvcmF0aW9uICYmIGRpc2FibGVTY3JvbGxSZXN0b3JhdGlvbigpO1xuICAgIH0sIFtyb3V0ZXIsIGJhc2VuYW1lLCBnZXRLZXldKTtcbiAgICAvLyBSZXN0b3JlIHNjcm9sbGluZyB3aGVuIHN0YXRlLnJlc3RvcmVTY3JvbGxQb3NpdGlvbiBjaGFuZ2VzXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL3J1bGVzLW9mLWhvb2tzXG4gICAgUmVhY3QudXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICAgIC8vIEV4cGxpY2l0IGZhbHNlIG1lYW5zIGRvbid0IGRvIGFueXRoaW5nICh1c2VkIGZvciBzdWJtaXNzaW9ucylcbiAgICAgIGlmIChyZXN0b3JlU2Nyb2xsUG9zaXRpb24gPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIC8vIGJlZW4gaGVyZSBiZWZvcmUsIHNjcm9sbCB0byBpdFxuICAgICAgaWYgKHR5cGVvZiByZXN0b3JlU2Nyb2xsUG9zaXRpb24gPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgd2luZG93LnNjcm9sbFRvKDAsIHJlc3RvcmVTY3JvbGxQb3NpdGlvbik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIC8vIHRyeSB0byBzY3JvbGwgdG8gdGhlIGhhc2hcbiAgICAgIGlmIChsb2NhdGlvbi5oYXNoKSB7XG4gICAgICAgIGxldCBlbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGRlY29kZVVSSUNvbXBvbmVudChsb2NhdGlvbi5oYXNoLnNsaWNlKDEpKSk7XG4gICAgICAgIGlmIChlbCkge1xuICAgICAgICAgIGVsLnNjcm9sbEludG9WaWV3KCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBEb24ndCByZXNldCBpZiB0aGlzIG5hdmlnYXRpb24gb3B0ZWQgb3V0XG4gICAgICBpZiAocHJldmVudFNjcm9sbFJlc2V0ID09PSB0cnVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIC8vIG90aGVyd2lzZSBnbyB0byB0aGUgdG9wIG9uIG5ldyBsb2NhdGlvbnNcbiAgICAgIHdpbmRvdy5zY3JvbGxUbygwLCAwKTtcbiAgICB9LCBbbG9jYXRpb24sIHJlc3RvcmVTY3JvbGxQb3NpdGlvbiwgcHJldmVudFNjcm9sbFJlc2V0XSk7XG4gIH1cbn1cbi8qKlxuICogU2V0dXAgYSBjYWxsYmFjayB0byBiZSBmaXJlZCBvbiB0aGUgd2luZG93J3MgYGJlZm9yZXVubG9hZGAgZXZlbnQuIFRoaXMgaXNcbiAqIHVzZWZ1bCBmb3Igc2F2aW5nIHNvbWUgZGF0YSB0byBgd2luZG93LmxvY2FsU3RvcmFnZWAganVzdCBiZWZvcmUgdGhlIHBhZ2VcbiAqIHJlZnJlc2hlcy5cbiAqXG4gKiBOb3RlOiBUaGUgYGNhbGxiYWNrYCBhcmd1bWVudCBzaG91bGQgYmUgYSBmdW5jdGlvbiBjcmVhdGVkIHdpdGhcbiAqIGBSZWFjdC51c2VDYWxsYmFjaygpYC5cbiAqL1xuZnVuY3Rpb24gdXNlQmVmb3JlVW5sb2FkKGNhbGxiYWNrLCBvcHRpb25zKSB7XG4gIGxldCB7XG4gICAgY2FwdHVyZVxuICB9ID0gb3B0aW9ucyB8fCB7fTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBsZXQgb3B0cyA9IGNhcHR1cmUgIT0gbnVsbCA/IHtcbiAgICAgIGNhcHR1cmVcbiAgICB9IDogdW5kZWZpbmVkO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiYmVmb3JldW5sb2FkXCIsIGNhbGxiYWNrLCBvcHRzKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJiZWZvcmV1bmxvYWRcIiwgY2FsbGJhY2ssIG9wdHMpO1xuICAgIH07XG4gIH0sIFtjYWxsYmFjaywgY2FwdHVyZV0pO1xufVxuLyoqXG4gKiBTZXR1cCBhIGNhbGxiYWNrIHRvIGJlIGZpcmVkIG9uIHRoZSB3aW5kb3cncyBgcGFnZWhpZGVgIGV2ZW50LiBUaGlzIGlzXG4gKiB1c2VmdWwgZm9yIHNhdmluZyBzb21lIGRhdGEgdG8gYHdpbmRvdy5sb2NhbFN0b3JhZ2VgIGp1c3QgYmVmb3JlIHRoZSBwYWdlXG4gKiByZWZyZXNoZXMuICBUaGlzIGV2ZW50IGlzIGJldHRlciBzdXBwb3J0ZWQgdGhhbiBiZWZvcmV1bmxvYWQgYWNyb3NzIGJyb3dzZXJzLlxuICpcbiAqIE5vdGU6IFRoZSBgY2FsbGJhY2tgIGFyZ3VtZW50IHNob3VsZCBiZSBhIGZ1bmN0aW9uIGNyZWF0ZWQgd2l0aFxuICogYFJlYWN0LnVzZUNhbGxiYWNrKClgLlxuICovXG5mdW5jdGlvbiB1c2VQYWdlSGlkZShjYWxsYmFjaywgb3B0aW9ucykge1xuICBsZXQge1xuICAgIGNhcHR1cmVcbiAgfSA9IG9wdGlvbnMgfHwge307XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgbGV0IG9wdHMgPSBjYXB0dXJlICE9IG51bGwgPyB7XG4gICAgICBjYXB0dXJlXG4gICAgfSA6IHVuZGVmaW5lZDtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInBhZ2VoaWRlXCIsIGNhbGxiYWNrLCBvcHRzKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJwYWdlaGlkZVwiLCBjYWxsYmFjaywgb3B0cyk7XG4gICAgfTtcbiAgfSwgW2NhbGxiYWNrLCBjYXB0dXJlXSk7XG59XG4vKipcbiAqIFdyYXBwZXIgYXJvdW5kIHVzZUJsb2NrZXIgdG8gc2hvdyBhIHdpbmRvdy5jb25maXJtIHByb21wdCB0byB1c2VycyBpbnN0ZWFkXG4gKiBvZiBidWlsZGluZyBhIGN1c3RvbSBVSSB3aXRoIHVzZUJsb2NrZXIuXG4gKlxuICogV2FybmluZzogVGhpcyBoYXMgKmEgbG90IG9mIHJvdWdoIGVkZ2VzKiBhbmQgYmVoYXZlcyB2ZXJ5IGRpZmZlcmVudGx5IChhbmRcbiAqIHZlcnkgaW5jb3JyZWN0bHkgaW4gc29tZSBjYXNlcykgYWNyb3NzIGJyb3dzZXJzIGlmIHVzZXIgY2xpY2sgYWRkaXRpb25cbiAqIGJhY2svZm9yd2FyZCBuYXZpZ2F0aW9ucyB3aGlsZSB0aGUgY29uZmlybSBpcyBvcGVuLiAgVXNlIGF0IHlvdXIgb3duIHJpc2suXG4gKi9cbmZ1bmN0aW9uIHVzZVByb21wdChfcmVmMTIpIHtcbiAgbGV0IHtcbiAgICB3aGVuLFxuICAgIG1lc3NhZ2VcbiAgfSA9IF9yZWYxMjtcbiAgbGV0IGJsb2NrZXIgPSB1c2VCbG9ja2VyKHdoZW4pO1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChibG9ja2VyLnN0YXRlID09PSBcImJsb2NrZWRcIikge1xuICAgICAgbGV0IHByb2NlZWQgPSB3aW5kb3cuY29uZmlybShtZXNzYWdlKTtcbiAgICAgIGlmIChwcm9jZWVkKSB7XG4gICAgICAgIC8vIFRoaXMgdGltZW91dCBpcyBuZWVkZWQgdG8gYXZvaWQgYSB3ZWlyZCBcInJhY2VcIiBvbiBQT1AgbmF2aWdhdGlvbnNcbiAgICAgICAgLy8gYmV0d2VlbiB0aGUgYHdpbmRvdy5oaXN0b3J5YCByZXZlcnQgbmF2aWdhdGlvbiBhbmQgdGhlIHJlc3VsdCBvZlxuICAgICAgICAvLyBgd2luZG93LmNvbmZpcm1gXG4gICAgICAgIHNldFRpbWVvdXQoYmxvY2tlci5wcm9jZWVkLCAwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJsb2NrZXIucmVzZXQoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIFtibG9ja2VyLCBtZXNzYWdlXSk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGJsb2NrZXIuc3RhdGUgPT09IFwiYmxvY2tlZFwiICYmICF3aGVuKSB7XG4gICAgICBibG9ja2VyLnJlc2V0KCk7XG4gICAgfVxuICB9LCBbYmxvY2tlciwgd2hlbl0pO1xufVxuLyoqXG4gKiBSZXR1cm4gYSBib29sZWFuIGluZGljYXRpbmcgaWYgdGhlcmUgaXMgYW4gYWN0aXZlIHZpZXcgdHJhbnNpdGlvbiB0byB0aGVcbiAqIGdpdmVuIGhyZWYuICBZb3UgY2FuIHVzZSB0aGlzIHZhbHVlIHRvIHJlbmRlciBDU1MgY2xhc3NlcyBvciB2aWV3VHJhbnNpdGlvbk5hbWVcbiAqIHN0eWxlcyBvbnRvIHlvdXIgZWxlbWVudHNcbiAqXG4gKiBAcGFyYW0gaHJlZiBUaGUgZGVzdGluYXRpb24gaHJlZlxuICogQHBhcmFtIFtvcHRzLnJlbGF0aXZlXSBSZWxhdGl2ZSByb3V0aW5nIHR5cGUgKFwicm91dGVcIiB8IFwicGF0aFwiKVxuICovXG5mdW5jdGlvbiB1c2VWaWV3VHJhbnNpdGlvblN0YXRlKHRvLCBvcHRzKSB7XG4gIGlmIChvcHRzID09PSB2b2lkIDApIHtcbiAgICBvcHRzID0ge307XG4gIH1cbiAgbGV0IHZ0Q29udGV4dCA9IFJlYWN0LnVzZUNvbnRleHQoVmlld1RyYW5zaXRpb25Db250ZXh0KTtcbiAgISh2dENvbnRleHQgIT0gbnVsbCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBVTlNBRkVfaW52YXJpYW50KGZhbHNlLCBcImB1bnN0YWJsZV91c2VWaWV3VHJhbnNpdGlvblN0YXRlYCBtdXN0IGJlIHVzZWQgd2l0aGluIGByZWFjdC1yb3V0ZXItZG9tYCdzIGBSb3V0ZXJQcm92aWRlcmAuICBcIiArIFwiRGlkIHlvdSBhY2NpZGVudGFsbHkgaW1wb3J0IGBSb3V0ZXJQcm92aWRlcmAgZnJvbSBgcmVhY3Qtcm91dGVyYD9cIikgOiBVTlNBRkVfaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgbGV0IHtcbiAgICBiYXNlbmFtZVxuICB9ID0gdXNlRGF0YVJvdXRlckNvbnRleHQoRGF0YVJvdXRlckhvb2sudXNlVmlld1RyYW5zaXRpb25TdGF0ZSk7XG4gIGxldCBwYXRoID0gdXNlUmVzb2x2ZWRQYXRoKHRvLCB7XG4gICAgcmVsYXRpdmU6IG9wdHMucmVsYXRpdmVcbiAgfSk7XG4gIGlmICghdnRDb250ZXh0LmlzVHJhbnNpdGlvbmluZykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBsZXQgY3VycmVudFBhdGggPSBzdHJpcEJhc2VuYW1lKHZ0Q29udGV4dC5jdXJyZW50TG9jYXRpb24ucGF0aG5hbWUsIGJhc2VuYW1lKSB8fCB2dENvbnRleHQuY3VycmVudExvY2F0aW9uLnBhdGhuYW1lO1xuICBsZXQgbmV4dFBhdGggPSBzdHJpcEJhc2VuYW1lKHZ0Q29udGV4dC5uZXh0TG9jYXRpb24ucGF0aG5hbWUsIGJhc2VuYW1lKSB8fCB2dENvbnRleHQubmV4dExvY2F0aW9uLnBhdGhuYW1lO1xuICAvLyBUcmFuc2l0aW9uIGlzIGFjdGl2ZSBpZiB3ZSdyZSBnb2luZyB0byBvciBjb21pbmcgZnJvbSB0aGUgaW5kaWNhdGVkXG4gIC8vIGRlc3RpbmF0aW9uLiAgVGhpcyBlbnN1cmVzIHRoYXQgb3RoZXIgUFVTSCBuYXZpZ2F0aW9ucyB0aGF0IHJldmVyc2VcbiAgLy8gYW4gaW5kaWNhdGVkIHRyYW5zaXRpb24gYXBwbHkuICBJLmUuLCBvbiB0aGUgbGlzdCB2aWV3IHlvdSBoYXZlOlxuICAvL1xuICAvLyAgIDxOYXZMaW5rIHRvPVwiL2RldGFpbHMvMVwiIHVuc3RhYmxlX3ZpZXdUcmFuc2l0aW9uPlxuICAvL1xuICAvLyBJZiB5b3UgY2xpY2sgdGhlIGJyZWFkY3J1bWIgYmFjayB0byB0aGUgbGlzdCB2aWV3OlxuICAvL1xuICAvLyAgIDxOYXZMaW5rIHRvPVwiL2xpc3RcIiB1bnN0YWJsZV92aWV3VHJhbnNpdGlvbj5cbiAgLy9cbiAgLy8gV2Ugc2hvdWxkIGFwcGx5IHRoZSB0cmFuc2l0aW9uIGJlY2F1c2UgaXQncyBpbmRpY2F0ZWQgYXMgYWN0aXZlIGdvaW5nXG4gIC8vIGZyb20gL2xpc3QgLT4gL2RldGFpbHMvMSBhbmQgdGhlcmVmb3JlIHNob3VsZCBiZSBhY3RpdmUgb24gdGhlIHJldmVyc2VcbiAgLy8gKGV2ZW4gdGhvdWdoIHRoaXMgaXNuJ3Qgc3RyaWN0bHkgYSBQT1AgcmV2ZXJzZSlcbiAgcmV0dXJuIG1hdGNoUGF0aChwYXRoLnBhdGhuYW1lLCBuZXh0UGF0aCkgIT0gbnVsbCB8fCBtYXRjaFBhdGgocGF0aC5wYXRobmFtZSwgY3VycmVudFBhdGgpICE9IG51bGw7XG59XG4vLyNlbmRyZWdpb25cblxuZXhwb3J0IHsgQnJvd3NlclJvdXRlciwgRm9ybSwgSGFzaFJvdXRlciwgTGluaywgTmF2TGluaywgUm91dGVyUHJvdmlkZXIsIFNjcm9sbFJlc3RvcmF0aW9uLCBGZXRjaGVyc0NvbnRleHQgYXMgVU5TQUZFX0ZldGNoZXJzQ29udGV4dCwgVmlld1RyYW5zaXRpb25Db250ZXh0IGFzIFVOU0FGRV9WaWV3VHJhbnNpdGlvbkNvbnRleHQsIHVzZVNjcm9sbFJlc3RvcmF0aW9uIGFzIFVOU0FGRV91c2VTY3JvbGxSZXN0b3JhdGlvbiwgY3JlYXRlQnJvd3NlclJvdXRlciwgY3JlYXRlSGFzaFJvdXRlciwgY3JlYXRlU2VhcmNoUGFyYW1zLCBIaXN0b3J5Um91dGVyIGFzIHVuc3RhYmxlX0hpc3RvcnlSb3V0ZXIsIHVzZVByb21wdCBhcyB1bnN0YWJsZV91c2VQcm9tcHQsIHVzZVZpZXdUcmFuc2l0aW9uU3RhdGUgYXMgdW5zdGFibGVfdXNlVmlld1RyYW5zaXRpb25TdGF0ZSwgdXNlQmVmb3JlVW5sb2FkLCB1c2VGZXRjaGVyLCB1c2VGZXRjaGVycywgdXNlRm9ybUFjdGlvbiwgdXNlTGlua0NsaWNrSGFuZGxlciwgdXNlU2VhcmNoUGFyYW1zLCB1c2VTdWJtaXQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIl0sIm5hbWVzIjpbIlJlYWN0IiwiUmVhY3RET00iLCJVTlNBRkVfbWFwUm91dGVQcm9wZXJ0aWVzIiwiVU5TQUZFX0RhdGFSb3V0ZXJDb250ZXh0IiwiVU5TQUZFX0RhdGFSb3V0ZXJTdGF0ZUNvbnRleHQiLCJSb3V0ZXIiLCJVTlNBRkVfdXNlUm91dGVzSW1wbCIsIlVOU0FGRV9OYXZpZ2F0aW9uQ29udGV4dCIsInVzZUhyZWYiLCJ1c2VSZXNvbHZlZFBhdGgiLCJ1c2VMb2NhdGlvbiIsInVzZU5hdmlnYXRlIiwiY3JlYXRlUGF0aCIsIlVOU0FGRV91c2VSb3V0ZUlkIiwiVU5TQUZFX1JvdXRlQ29udGV4dCIsInVzZU1hdGNoZXMiLCJ1c2VOYXZpZ2F0aW9uIiwidXNlQmxvY2tlciIsIkFib3J0ZWREZWZlcnJlZEVycm9yIiwiQXdhaXQiLCJNZW1vcnlSb3V0ZXIiLCJOYXZpZ2F0ZSIsIk5hdmlnYXRpb25UeXBlIiwiT3V0bGV0IiwiUm91dGUiLCJSb3V0ZXMiLCJVTlNBRkVfTG9jYXRpb25Db250ZXh0IiwiY3JlYXRlTWVtb3J5Um91dGVyIiwiY3JlYXRlUm91dGVzRnJvbUNoaWxkcmVuIiwiY3JlYXRlUm91dGVzRnJvbUVsZW1lbnRzIiwiZGVmZXIiLCJnZW5lcmF0ZVBhdGgiLCJpc1JvdXRlRXJyb3JSZXNwb25zZSIsImpzb24iLCJtYXRjaFBhdGgiLCJtYXRjaFJvdXRlcyIsInBhcnNlUGF0aCIsInJlZGlyZWN0IiwicmVkaXJlY3REb2N1bWVudCIsInJlbmRlck1hdGNoZXMiLCJyZXNvbHZlUGF0aCIsInVzZUFjdGlvbkRhdGEiLCJ1c2VBc3luY0Vycm9yIiwidXNlQXN5bmNWYWx1ZSIsInVzZUluUm91dGVyQ29udGV4dCIsInVzZUxvYWRlckRhdGEiLCJ1c2VNYXRjaCIsInVzZU5hdmlnYXRpb25UeXBlIiwidXNlT3V0bGV0IiwidXNlT3V0bGV0Q29udGV4dCIsInVzZVBhcmFtcyIsInVzZVJldmFsaWRhdG9yIiwidXNlUm91dGVFcnJvciIsInVzZVJvdXRlTG9hZGVyRGF0YSIsInVzZVJvdXRlcyIsInN0cmlwQmFzZW5hbWUiLCJVTlNBRkVfd2FybmluZyIsImNyZWF0ZVJvdXRlciIsImNyZWF0ZUJyb3dzZXJIaXN0b3J5IiwiY3JlYXRlSGFzaEhpc3RvcnkiLCJVTlNBRkVfRXJyb3JSZXNwb25zZUltcGwiLCJVTlNBRkVfaW52YXJpYW50Iiwiam9pblBhdGhzIiwiSURMRV9GRVRDSEVSIiwiX2V4dGVuZHMiLCJPYmplY3QiLCJhc3NpZ24iLCJiaW5kIiwidGFyZ2V0IiwiaSIsImFyZ3VtZW50cyIsImxlbmd0aCIsInNvdXJjZSIsImtleSIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsImFwcGx5IiwiX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UiLCJleGNsdWRlZCIsInNvdXJjZUtleXMiLCJrZXlzIiwiaW5kZXhPZiIsImRlZmF1bHRNZXRob2QiLCJkZWZhdWx0RW5jVHlwZSIsImlzSHRtbEVsZW1lbnQiLCJvYmplY3QiLCJ0YWdOYW1lIiwiaXNCdXR0b25FbGVtZW50IiwidG9Mb3dlckNhc2UiLCJpc0Zvcm1FbGVtZW50IiwiaXNJbnB1dEVsZW1lbnQiLCJpc01vZGlmaWVkRXZlbnQiLCJldmVudCIsIm1ldGFLZXkiLCJhbHRLZXkiLCJjdHJsS2V5Iiwic2hpZnRLZXkiLCJzaG91bGRQcm9jZXNzTGlua0NsaWNrIiwiYnV0dG9uIiwiY3JlYXRlU2VhcmNoUGFyYW1zIiwiaW5pdCIsIlVSTFNlYXJjaFBhcmFtcyIsIkFycmF5IiwiaXNBcnJheSIsInJlZHVjZSIsIm1lbW8iLCJ2YWx1ZSIsImNvbmNhdCIsIm1hcCIsInYiLCJnZXRTZWFyY2hQYXJhbXNGb3JMb2NhdGlvbiIsImxvY2F0aW9uU2VhcmNoIiwiZGVmYXVsdFNlYXJjaFBhcmFtcyIsInNlYXJjaFBhcmFtcyIsImZvckVhY2giLCJfIiwiaGFzIiwiZ2V0QWxsIiwiYXBwZW5kIiwiX2Zvcm1EYXRhU3VwcG9ydHNTdWJtaXR0ZXIiLCJpc0Zvcm1EYXRhU3VibWl0dGVyU3VwcG9ydGVkIiwiRm9ybURhdGEiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJlIiwic3VwcG9ydGVkRm9ybUVuY1R5cGVzIiwiU2V0IiwiZ2V0Rm9ybUVuY1R5cGUiLCJlbmNUeXBlIiwiZ2V0Rm9ybVN1Ym1pc3Npb25JbmZvIiwiYmFzZW5hbWUiLCJtZXRob2QiLCJhY3Rpb24iLCJmb3JtRGF0YSIsImJvZHkiLCJhdHRyIiwiZ2V0QXR0cmlidXRlIiwidHlwZSIsImZvcm0iLCJFcnJvciIsIm5hbWUiLCJwcmVmaXgiLCJ1bmRlZmluZWQiLCJfZXhjbHVkZWQiLCJfZXhjbHVkZWQyIiwiX2V4Y2x1ZGVkMyIsImNyZWF0ZUJyb3dzZXJSb3V0ZXIiLCJyb3V0ZXMiLCJvcHRzIiwiZnV0dXJlIiwidjdfcHJlcGVuZEJhc2VuYW1lIiwiaGlzdG9yeSIsIndpbmRvdyIsImh5ZHJhdGlvbkRhdGEiLCJwYXJzZUh5ZHJhdGlvbkRhdGEiLCJtYXBSb3V0ZVByb3BlcnRpZXMiLCJpbml0aWFsaXplIiwiY3JlYXRlSGFzaFJvdXRlciIsIl93aW5kb3ciLCJzdGF0ZSIsIl9fc3RhdGljUm91dGVySHlkcmF0aW9uRGF0YSIsImVycm9ycyIsImRlc2VyaWFsaXplRXJyb3JzIiwiZW50cmllcyIsInNlcmlhbGl6ZWQiLCJ2YWwiLCJfX3R5cGUiLCJzdGF0dXMiLCJzdGF0dXNUZXh0IiwiZGF0YSIsImludGVybmFsIiwiX19zdWJUeXBlIiwiRXJyb3JDb25zdHJ1Y3RvciIsImVycm9yIiwibWVzc2FnZSIsInN0YWNrIiwiVmlld1RyYW5zaXRpb25Db250ZXh0IiwiY3JlYXRlQ29udGV4dCIsImlzVHJhbnNpdGlvbmluZyIsInByb2Nlc3MiLCJkaXNwbGF5TmFtZSIsIkZldGNoZXJzQ29udGV4dCIsIk1hcCIsIlNUQVJUX1RSQU5TSVRJT04iLCJzdGFydFRyYW5zaXRpb25JbXBsIiwiRkxVU0hfU1lOQyIsImZsdXNoU3luY0ltcGwiLCJzdGFydFRyYW5zaXRpb25TYWZlIiwiY2IiLCJmbHVzaFN5bmNTYWZlIiwiRGVmZXJyZWQiLCJjb25zdHJ1Y3RvciIsInByb21pc2UiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsInJlYXNvbiIsIlJvdXRlclByb3ZpZGVyIiwiX3JlZiIsImZhbGxiYWNrRWxlbWVudCIsInJvdXRlciIsInNldFN0YXRlSW1wbCIsInVzZVN0YXRlIiwicGVuZGluZ1N0YXRlIiwic2V0UGVuZGluZ1N0YXRlIiwidnRDb250ZXh0Iiwic2V0VnRDb250ZXh0IiwicmVuZGVyRGZkIiwic2V0UmVuZGVyRGZkIiwidHJhbnNpdGlvbiIsInNldFRyYW5zaXRpb24iLCJpbnRlcnJ1cHRpb24iLCJzZXRJbnRlcnJ1cHRpb24iLCJmZXRjaGVyRGF0YSIsInVzZVJlZiIsInY3X3N0YXJ0VHJhbnNpdGlvbiIsIm9wdEluU3RhcnRUcmFuc2l0aW9uIiwidXNlQ2FsbGJhY2siLCJzZXRTdGF0ZSIsIm5ld1N0YXRlIiwiX3JlZjIiLCJkZWxldGVkRmV0Y2hlcnMiLCJ1bnN0YWJsZV9mbHVzaFN5bmMiLCJmbHVzaFN5bmMiLCJ1bnN0YWJsZV92aWV3VHJhbnNpdGlvbk9wdHMiLCJ2aWV3VHJhbnNpdGlvbk9wdHMiLCJjdXJyZW50IiwiZGVsZXRlIiwiZmV0Y2hlcnMiLCJmZXRjaGVyIiwic2V0IiwiaXNWaWV3VHJhbnNpdGlvblVuYXZhaWxhYmxlIiwic3RhcnRWaWV3VHJhbnNpdGlvbiIsInNraXBUcmFuc2l0aW9uIiwiY3VycmVudExvY2F0aW9uIiwibmV4dExvY2F0aW9uIiwidCIsImZpbmlzaGVkIiwiZmluYWxseSIsInVzZUxheW91dEVmZmVjdCIsInN1YnNjcmliZSIsInVzZUVmZmVjdCIsInJlbmRlclByb21pc2UiLCJsb2NhdGlvbiIsIm5hdmlnYXRvciIsInVzZU1lbW8iLCJjcmVhdGVIcmVmIiwiZW5jb2RlTG9jYXRpb24iLCJnbyIsIm4iLCJuYXZpZ2F0ZSIsInB1c2giLCJ0byIsInByZXZlbnRTY3JvbGxSZXNldCIsInJlcGxhY2UiLCJkYXRhUm91dGVyQ29udGV4dCIsInN0YXRpYyIsIkZyYWdtZW50IiwiUHJvdmlkZXIiLCJuYXZpZ2F0aW9uVHlwZSIsImhpc3RvcnlBY3Rpb24iLCJpbml0aWFsaXplZCIsIkRhdGFSb3V0ZXMiLCJfcmVmMyIsIkJyb3dzZXJSb3V0ZXIiLCJfcmVmNCIsImNoaWxkcmVuIiwiaGlzdG9yeVJlZiIsInY1Q29tcGF0IiwibGlzdGVuIiwiSGFzaFJvdXRlciIsIl9yZWY1IiwiSGlzdG9yeVJvdXRlciIsIl9yZWY2IiwiaXNCcm93c2VyIiwiQUJTT0xVVEVfVVJMX1JFR0VYIiwiTGluayIsImZvcndhcmRSZWYiLCJMaW5rV2l0aFJlZiIsIl9yZWY3IiwicmVmIiwib25DbGljayIsInJlbGF0aXZlIiwicmVsb2FkRG9jdW1lbnQiLCJ1bnN0YWJsZV92aWV3VHJhbnNpdGlvbiIsInJlc3QiLCJ1c2VDb250ZXh0IiwiYWJzb2x1dGVIcmVmIiwiaXNFeHRlcm5hbCIsInRlc3QiLCJjdXJyZW50VXJsIiwiVVJMIiwiaHJlZiIsInRhcmdldFVybCIsInN0YXJ0c1dpdGgiLCJwcm90b2NvbCIsInBhdGgiLCJwYXRobmFtZSIsIm9yaWdpbiIsInNlYXJjaCIsImhhc2giLCJpbnRlcm5hbE9uQ2xpY2siLCJ1c2VMaW5rQ2xpY2tIYW5kbGVyIiwiaGFuZGxlQ2xpY2siLCJkZWZhdWx0UHJldmVudGVkIiwiTmF2TGluayIsIk5hdkxpbmtXaXRoUmVmIiwiX3JlZjgiLCJhcmlhQ3VycmVudFByb3AiLCJjYXNlU2Vuc2l0aXZlIiwiY2xhc3NOYW1lIiwiY2xhc3NOYW1lUHJvcCIsImVuZCIsInN0eWxlIiwic3R5bGVQcm9wIiwicm91dGVyU3RhdGUiLCJ1c2VWaWV3VHJhbnNpdGlvblN0YXRlIiwidG9QYXRobmFtZSIsImxvY2F0aW9uUGF0aG5hbWUiLCJuZXh0TG9jYXRpb25QYXRobmFtZSIsIm5hdmlnYXRpb24iLCJlbmRTbGFzaFBvc2l0aW9uIiwiZW5kc1dpdGgiLCJpc0FjdGl2ZSIsImNoYXJBdCIsImlzUGVuZGluZyIsInJlbmRlclByb3BzIiwiYXJpYUN1cnJlbnQiLCJmaWx0ZXIiLCJCb29sZWFuIiwiam9pbiIsIkZvcm0iLCJfcmVmOSIsImZvcndhcmRlZFJlZiIsImZldGNoZXJLZXkiLCJvblN1Ym1pdCIsInByb3BzIiwic3VibWl0IiwidXNlU3VibWl0IiwiZm9ybUFjdGlvbiIsInVzZUZvcm1BY3Rpb24iLCJmb3JtTWV0aG9kIiwic3VibWl0SGFuZGxlciIsInByZXZlbnREZWZhdWx0Iiwic3VibWl0dGVyIiwibmF0aXZlRXZlbnQiLCJzdWJtaXRNZXRob2QiLCJjdXJyZW50VGFyZ2V0IiwiU2Nyb2xsUmVzdG9yYXRpb24iLCJfcmVmMTAiLCJnZXRLZXkiLCJzdG9yYWdlS2V5IiwidXNlU2Nyb2xsUmVzdG9yYXRpb24iLCJEYXRhUm91dGVySG9vayIsIkRhdGFSb3V0ZXJTdGF0ZUhvb2siLCJnZXREYXRhUm91dGVyQ29uc29sZUVycm9yIiwiaG9va05hbWUiLCJ1c2VEYXRhUm91dGVyQ29udGV4dCIsImN0eCIsInVzZURhdGFSb3V0ZXJTdGF0ZSIsIl90ZW1wIiwicmVwbGFjZVByb3AiLCJ1c2VTZWFyY2hQYXJhbXMiLCJkZWZhdWx0SW5pdCIsImRlZmF1bHRTZWFyY2hQYXJhbXNSZWYiLCJoYXNTZXRTZWFyY2hQYXJhbXNSZWYiLCJzZXRTZWFyY2hQYXJhbXMiLCJuZXh0SW5pdCIsIm5hdmlnYXRlT3B0aW9ucyIsIm5ld1NlYXJjaFBhcmFtcyIsInZhbGlkYXRlQ2xpZW50U2lkZVN1Ym1pc3Npb24iLCJmZXRjaGVySWQiLCJnZXRVbmlxdWVGZXRjaGVySWQiLCJTdHJpbmciLCJVc2VTdWJtaXQiLCJjdXJyZW50Um91dGVJZCIsIm9wdGlvbnMiLCJmZXRjaCIsImZvcm1FbmNUeXBlIiwiZnJvbVJvdXRlSWQiLCJfdGVtcDIiLCJyb3V0ZUNvbnRleHQiLCJtYXRjaCIsIm1hdGNoZXMiLCJzbGljZSIsInBhcmFtcyIsImdldCIsInRvU3RyaW5nIiwicm91dGUiLCJpbmRleCIsInVzZUZldGNoZXIiLCJfdGVtcDMiLCJfcm91dGUkbWF0Y2hlcyIsIlVzZUZldGNoZXIiLCJyb3V0ZUlkIiwiaWQiLCJzZXRGZXRjaGVyS2V5IiwiZ2V0RmV0Y2hlciIsImRlbGV0ZUZldGNoZXIiLCJsb2FkIiwic3VibWl0SW1wbCIsIkZldGNoZXJGb3JtIiwiZmV0Y2hlcldpdGhDb21wb25lbnRzIiwidXNlRmV0Y2hlcnMiLCJVc2VGZXRjaGVycyIsImZyb20iLCJfcmVmMTEiLCJTQ1JPTExfUkVTVE9SQVRJT05fU1RPUkFHRV9LRVkiLCJzYXZlZFNjcm9sbFBvc2l0aW9ucyIsIl90ZW1wNCIsIlVzZVNjcm9sbFJlc3RvcmF0aW9uIiwicmVzdG9yZVNjcm9sbFBvc2l0aW9uIiwic2Nyb2xsUmVzdG9yYXRpb24iLCJ1c2VQYWdlSGlkZSIsInNjcm9sbFkiLCJzZXNzaW9uU3RvcmFnZSIsInNldEl0ZW0iLCJKU09OIiwic3RyaW5naWZ5Iiwic2Vzc2lvblBvc2l0aW9ucyIsImdldEl0ZW0iLCJwYXJzZSIsImdldEtleVdpdGhvdXRCYXNlbmFtZSIsImRpc2FibGVTY3JvbGxSZXN0b3JhdGlvbiIsImVuYWJsZVNjcm9sbFJlc3RvcmF0aW9uIiwic2Nyb2xsVG8iLCJlbCIsImdldEVsZW1lbnRCeUlkIiwiZGVjb2RlVVJJQ29tcG9uZW50Iiwic2Nyb2xsSW50b1ZpZXciLCJ1c2VCZWZvcmVVbmxvYWQiLCJjYWxsYmFjayIsImNhcHR1cmUiLCJhZGRFdmVudExpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsInVzZVByb21wdCIsIl9yZWYxMiIsIndoZW4iLCJibG9ja2VyIiwicHJvY2VlZCIsImNvbmZpcm0iLCJzZXRUaW1lb3V0IiwicmVzZXQiLCJjdXJyZW50UGF0aCIsIm5leHRQYXRoIiwiVU5TQUZFX0ZldGNoZXJzQ29udGV4dCIsIlVOU0FGRV9WaWV3VHJhbnNpdGlvbkNvbnRleHQiLCJVTlNBRkVfdXNlU2Nyb2xsUmVzdG9yYXRpb24iLCJ1bnN0YWJsZV9IaXN0b3J5Um91dGVyIiwidW5zdGFibGVfdXNlUHJvbXB0IiwidW5zdGFibGVfdXNlVmlld1RyYW5zaXRpb25TdGF0ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-router-dom/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/react-router-dom/server.js":
/*!*************************************************!*\
  !*** ./node_modules/react-router-dom/server.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nvar React = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\nvar router = __webpack_require__(/*! @remix-run/router */ \"(ssr)/./node_modules/@remix-run/router/dist/router.js\");\nvar reactRouter = __webpack_require__(/*! react-router */ \"(ssr)/./node_modules/react-router/dist/index.js\");\nvar reactRouterDom = __webpack_require__(/*! react-router-dom */ \"(ssr)/./node_modules/react-router-dom/dist/index.js\");\nfunction _interopNamespace(e) {\n    if (e && e.__esModule) return e;\n    var n = Object.create(null);\n    if (e) {\n        Object.keys(e).forEach(function(k) {\n            if (k !== \"default\") {\n                var d = Object.getOwnPropertyDescriptor(e, k);\n                Object.defineProperty(n, k, d.get ? d : {\n                    enumerable: true,\n                    get: function() {\n                        return e[k];\n                    }\n                });\n            }\n        });\n    }\n    n[\"default\"] = e;\n    return Object.freeze(n);\n}\nvar React__namespace = /*#__PURE__*/ _interopNamespace(React);\n/**\n * A `<Router>` that may not navigate to any other location. This is useful\n * on the server where there is no stateful UI.\n */ function StaticRouter({ basename, children, location: locationProp = \"/\" }) {\n    if (typeof locationProp === \"string\") {\n        locationProp = reactRouterDom.parsePath(locationProp);\n    }\n    let action = router.Action.Pop;\n    let location = {\n        pathname: locationProp.pathname || \"/\",\n        search: locationProp.search || \"\",\n        hash: locationProp.hash || \"\",\n        state: locationProp.state || null,\n        key: locationProp.key || \"default\"\n    };\n    let staticNavigator = getStatelessNavigator();\n    return /*#__PURE__*/ React__namespace.createElement(reactRouterDom.Router, {\n        basename: basename,\n        children: children,\n        location: location,\n        navigationType: action,\n        navigator: staticNavigator,\n        static: true\n    });\n}\n/**\n * A Data Router that may not navigate to any other location. This is useful\n * on the server where there is no stateful UI.\n */ function StaticRouterProvider({ context, router: router$1, hydrate = true, nonce }) {\n    !(router$1 && context) ?  true ? router.UNSAFE_invariant(false, \"You must provide `router` and `context` to <StaticRouterProvider>\") : 0 : void 0;\n    let dataRouterContext = {\n        router: router$1,\n        navigator: getStatelessNavigator(),\n        static: true,\n        staticContext: context,\n        basename: context.basename || \"/\"\n    };\n    let fetchersContext = new Map();\n    let hydrateScript = \"\";\n    if (hydrate !== false) {\n        let data = {\n            loaderData: context.loaderData,\n            actionData: context.actionData,\n            errors: serializeErrors(context.errors)\n        };\n        // Use JSON.parse here instead of embedding a raw JS object here to speed\n        // up parsing on the client.  Dual-stringify is needed to ensure all quotes\n        // are properly escaped in the resulting string.  See:\n        //   https://v8.dev/blog/cost-of-javascript-2019#json\n        let json = htmlEscape(JSON.stringify(JSON.stringify(data)));\n        hydrateScript = `window.__staticRouterHydrationData = JSON.parse(${json});`;\n    }\n    let { state } = dataRouterContext.router;\n    return /*#__PURE__*/ React__namespace.createElement(React__namespace.Fragment, null, /*#__PURE__*/ React__namespace.createElement(reactRouterDom.UNSAFE_DataRouterContext.Provider, {\n        value: dataRouterContext\n    }, /*#__PURE__*/ React__namespace.createElement(reactRouterDom.UNSAFE_DataRouterStateContext.Provider, {\n        value: state\n    }, /*#__PURE__*/ React__namespace.createElement(reactRouterDom.UNSAFE_FetchersContext.Provider, {\n        value: fetchersContext\n    }, /*#__PURE__*/ React__namespace.createElement(reactRouterDom.UNSAFE_ViewTransitionContext.Provider, {\n        value: {\n            isTransitioning: false\n        }\n    }, /*#__PURE__*/ React__namespace.createElement(reactRouterDom.Router, {\n        basename: dataRouterContext.basename,\n        location: state.location,\n        navigationType: state.historyAction,\n        navigator: dataRouterContext.navigator,\n        static: dataRouterContext.static\n    }, /*#__PURE__*/ React__namespace.createElement(DataRoutes, {\n        routes: router$1.routes,\n        state: state\n    })))))), hydrateScript ? /*#__PURE__*/ React__namespace.createElement(\"script\", {\n        suppressHydrationWarning: true,\n        nonce: nonce,\n        dangerouslySetInnerHTML: {\n            __html: hydrateScript\n        }\n    }) : null);\n}\nfunction DataRoutes({ routes, state }) {\n    return reactRouter.UNSAFE_useRoutesImpl(routes, undefined, state);\n}\nfunction serializeErrors(errors) {\n    if (!errors) return null;\n    let entries = Object.entries(errors);\n    let serialized = {};\n    for (let [key, val] of entries){\n        // Hey you!  If you change this, please change the corresponding logic in\n        // deserializeErrors in react-router-dom/index.tsx :)\n        if (router.isRouteErrorResponse(val)) {\n            serialized[key] = {\n                ...val,\n                __type: \"RouteErrorResponse\"\n            };\n        } else if (val instanceof Error) {\n            // Do not serialize stack traces from SSR for security reasons\n            serialized[key] = {\n                message: val.message,\n                __type: \"Error\",\n                // If this is a subclass (i.e., ReferenceError), send up the type so we\n                // can re-create the same type during hydration.\n                ...val.name !== \"Error\" ? {\n                    __subType: val.name\n                } : {}\n            };\n        } else {\n            serialized[key] = val;\n        }\n    }\n    return serialized;\n}\nfunction getStatelessNavigator() {\n    return {\n        createHref,\n        encodeLocation,\n        push (to) {\n            throw new Error(`You cannot use navigator.push() on the server because it is a stateless ` + `environment. This error was probably triggered when you did a ` + `\\`navigate(${JSON.stringify(to)})\\` somewhere in your app.`);\n        },\n        replace (to) {\n            throw new Error(`You cannot use navigator.replace() on the server because it is a stateless ` + `environment. This error was probably triggered when you did a ` + `\\`navigate(${JSON.stringify(to)}, { replace: true })\\` somewhere ` + `in your app.`);\n        },\n        go (delta) {\n            throw new Error(`You cannot use navigator.go() on the server because it is a stateless ` + `environment. This error was probably triggered when you did a ` + `\\`navigate(${delta})\\` somewhere in your app.`);\n        },\n        back () {\n            throw new Error(`You cannot use navigator.back() on the server because it is a stateless ` + `environment.`);\n        },\n        forward () {\n            throw new Error(`You cannot use navigator.forward() on the server because it is a stateless ` + `environment.`);\n        }\n    };\n}\nfunction createStaticHandler(routes, opts) {\n    return router.createStaticHandler(routes, {\n        ...opts,\n        mapRouteProperties: reactRouter.UNSAFE_mapRouteProperties\n    });\n}\nfunction createStaticRouter(routes, context) {\n    let manifest = {};\n    let dataRoutes = router.UNSAFE_convertRoutesToDataRoutes(routes, reactRouter.UNSAFE_mapRouteProperties, undefined, manifest);\n    // Because our context matches may be from a framework-agnostic set of\n    // routes passed to createStaticHandler(), we update them here with our\n    // newly created/enhanced data routes\n    let matches = context.matches.map((match)=>{\n        let route = manifest[match.route.id] || match.route;\n        return {\n            ...match,\n            route\n        };\n    });\n    let msg = (method)=>`You cannot use router.${method}() on the server because it is a stateless environment`;\n    return {\n        get basename () {\n            return context.basename;\n        },\n        get state () {\n            return {\n                historyAction: router.Action.Pop,\n                location: context.location,\n                matches,\n                loaderData: context.loaderData,\n                actionData: context.actionData,\n                errors: context.errors,\n                initialized: true,\n                navigation: router.IDLE_NAVIGATION,\n                restoreScrollPosition: null,\n                preventScrollReset: false,\n                revalidation: \"idle\",\n                fetchers: new Map(),\n                blockers: new Map()\n            };\n        },\n        get routes () {\n            return dataRoutes;\n        },\n        get window () {\n            return undefined;\n        },\n        initialize () {\n            throw msg(\"initialize\");\n        },\n        subscribe () {\n            throw msg(\"subscribe\");\n        },\n        enableScrollRestoration () {\n            throw msg(\"enableScrollRestoration\");\n        },\n        navigate () {\n            throw msg(\"navigate\");\n        },\n        fetch () {\n            throw msg(\"fetch\");\n        },\n        revalidate () {\n            throw msg(\"revalidate\");\n        },\n        createHref,\n        encodeLocation,\n        getFetcher () {\n            return router.IDLE_FETCHER;\n        },\n        deleteFetcher () {\n            throw msg(\"deleteFetcher\");\n        },\n        dispose () {\n            throw msg(\"dispose\");\n        },\n        getBlocker () {\n            return router.IDLE_BLOCKER;\n        },\n        deleteBlocker () {\n            throw msg(\"deleteBlocker\");\n        },\n        _internalFetchControllers: new Map(),\n        _internalActiveDeferreds: new Map(),\n        _internalSetRoutes () {\n            throw msg(\"_internalSetRoutes\");\n        }\n    };\n}\nfunction createHref(to) {\n    return typeof to === \"string\" ? to : reactRouterDom.createPath(to);\n}\nfunction encodeLocation(to) {\n    let href = typeof to === \"string\" ? to : reactRouterDom.createPath(to);\n    let encoded = ABSOLUTE_URL_REGEX.test(href) ? new URL(href) : new URL(href, \"http://localhost\");\n    return {\n        pathname: encoded.pathname,\n        search: encoded.search,\n        hash: encoded.hash\n    };\n}\nconst ABSOLUTE_URL_REGEX = /^(?:[a-z][a-z0-9+.-]*:|\\/\\/)/i;\n// This utility is based on https://github.com/zertosh/htmlescape\n// License: https://github.com/zertosh/htmlescape/blob/0527ca7156a524d256101bb310a9f970f63078ad/LICENSE\nconst ESCAPE_LOOKUP = {\n    \"&\": \"\\\\u0026\",\n    \">\": \"\\\\u003e\",\n    \"<\": \"\\\\u003c\",\n    \"\\u2028\": \"\\\\u2028\",\n    \"\\u2029\": \"\\\\u2029\"\n};\nconst ESCAPE_REGEX = /[&><\\u2028\\u2029]/g;\nfunction htmlEscape(str) {\n    return str.replace(ESCAPE_REGEX, (match)=>ESCAPE_LOOKUP[match]);\n}\nexports.StaticRouter = StaticRouter;\nexports.StaticRouterProvider = StaticRouterProvider;\nexports.createStaticHandler = createStaticHandler;\nexports.createStaticRouter = createStaticRouter;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyLWRvbS9zZXJ2ZXIuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQUEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFFN0QsSUFBSUMsUUFBUUMsbUJBQU9BLENBQUM7QUFDcEIsSUFBSUMsU0FBU0QsbUJBQU9BLENBQUM7QUFDckIsSUFBSUUsY0FBY0YsbUJBQU9BLENBQUM7QUFDMUIsSUFBSUcsaUJBQWlCSCxtQkFBT0EsQ0FBQztBQUU3QixTQUFTSSxrQkFBa0JDLENBQUM7SUFDeEIsSUFBSUEsS0FBS0EsRUFBRUMsVUFBVSxFQUFFLE9BQU9EO0lBQzlCLElBQUlFLElBQUlaLE9BQU9hLE1BQU0sQ0FBQztJQUN0QixJQUFJSCxHQUFHO1FBQ0hWLE9BQU9jLElBQUksQ0FBQ0osR0FBR0ssT0FBTyxDQUFDLFNBQVVDLENBQUM7WUFDOUIsSUFBSUEsTUFBTSxXQUFXO2dCQUNqQixJQUFJQyxJQUFJakIsT0FBT2tCLHdCQUF3QixDQUFDUixHQUFHTTtnQkFDM0NoQixPQUFPQyxjQUFjLENBQUNXLEdBQUdJLEdBQUdDLEVBQUVFLEdBQUcsR0FBR0YsSUFBSTtvQkFDcENHLFlBQVk7b0JBQ1pELEtBQUs7d0JBQWMsT0FBT1QsQ0FBQyxDQUFDTSxFQUFFO29CQUFFO2dCQUNwQztZQUNKO1FBQ0o7SUFDSjtJQUNBSixDQUFDLENBQUMsVUFBVSxHQUFHRjtJQUNmLE9BQU9WLE9BQU9xQixNQUFNLENBQUNUO0FBQ3pCO0FBRUEsSUFBSVUsbUJBQW1CLFdBQVcsR0FBRWIsa0JBQWtCTDtBQUV0RDs7O0NBR0MsR0FDRCxTQUFTbUIsYUFBYSxFQUNwQkMsUUFBUSxFQUNSQyxRQUFRLEVBQ1JDLFVBQVVDLGVBQWUsR0FBRyxFQUM3QjtJQUNDLElBQUksT0FBT0EsaUJBQWlCLFVBQVU7UUFDcENBLGVBQWVuQixlQUFlb0IsU0FBUyxDQUFDRDtJQUMxQztJQUNBLElBQUlFLFNBQVN2QixPQUFPd0IsTUFBTSxD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RjtZQUNFLE1BQU0xQixJQUFJO1FBQ1o7SUFDRjtBQUNGO0FBQ0EsU0FBU3RCLFdBQVdHLEVBQUU7SUFDcEIsT0FBTyxPQUFPQSxPQUFPLFdBQVdBLEtBQUtwRixlQUFla0ksVUFBVSxDQUFDOUM7QUFDakU7QUFDQSxTQUFTRixlQUFlRSxFQUFFO0lBQ3hCLElBQUkrQyxPQUFPLE9BQU8vQyxPQUFPLFdBQVdBLEtBQUtwRixlQUFla0ksVUFBVSxDQUFDOUM7SUFDbkUsSUFBSWdELFVBQVVDLG1CQUFtQkMsSUFBSSxDQUFDSCxRQUFRLElBQUlJLElBQUlKLFFBQVEsSUFBSUksSUFBSUosTUFBTTtJQUM1RSxPQUFPO1FBQ0wzRyxVQUFVNEcsUUFBUTVHLFFBQVE7UUFDMUJDLFFBQVEyRyxRQUFRM0csTUFBTTtRQUN0QkMsTUFBTTBHLFFBQVExRyxJQUFJO0lBQ3BCO0FBQ0Y7QUFDQSxNQUFNMkcscUJBQXFCO0FBQzNCLGlFQUFpRTtBQUNqRSx1R0FBdUc7QUFDdkcsTUFBTUcsZ0JBQWdCO0lBQ3BCLEtBQUs7SUFDTCxLQUFLO0lBQ0wsS0FBSztJQUNMLFVBQVU7SUFDVixVQUFVO0FBQ1o7QUFDQSxNQUFNQyxlQUFlO0FBQ3JCLFNBQVNuRixXQUFXb0YsR0FBRztJQUNyQixPQUFPQSxJQUFJckQsT0FBTyxDQUFDb0QsY0FBY3JDLENBQUFBLFFBQVNvQyxhQUFhLENBQUNwQyxNQUFNO0FBQ2hFO0FBRUExRyxvQkFBb0IsR0FBR3FCO0FBQ3ZCckIsNEJBQTRCLEdBQUcwQztBQUMvQjFDLDJCQUEyQixHQUFHZ0c7QUFDOUJoRywwQkFBMEIsR0FBR29HIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyLWRvbS9zZXJ2ZXIuanM/NGRmNyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG52YXIgcm91dGVyID0gcmVxdWlyZSgnQHJlbWl4LXJ1bi9yb3V0ZXInKTtcbnZhciByZWFjdFJvdXRlciA9IHJlcXVpcmUoJ3JlYWN0LXJvdXRlcicpO1xudmFyIHJlYWN0Um91dGVyRG9tID0gcmVxdWlyZSgncmVhY3Qtcm91dGVyLWRvbScpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcE5hbWVzcGFjZShlKSB7XG4gICAgaWYgKGUgJiYgZS5fX2VzTW9kdWxlKSByZXR1cm4gZTtcbiAgICB2YXIgbiA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgaWYgKGUpIHtcbiAgICAgICAgT2JqZWN0LmtleXMoZSkuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgaWYgKGsgIT09ICdkZWZhdWx0Jykge1xuICAgICAgICAgICAgICAgIHZhciBkID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCBrKTtcbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobiwgaywgZC5nZXQgPyBkIDoge1xuICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVba107IH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG5bXCJkZWZhdWx0XCJdID0gZTtcbiAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZShuKTtcbn1cblxudmFyIFJlYWN0X19uYW1lc3BhY2UgPSAvKiNfX1BVUkVfXyovX2ludGVyb3BOYW1lc3BhY2UoUmVhY3QpO1xuXG4vKipcbiAqIEEgYDxSb3V0ZXI+YCB0aGF0IG1heSBub3QgbmF2aWdhdGUgdG8gYW55IG90aGVyIGxvY2F0aW9uLiBUaGlzIGlzIHVzZWZ1bFxuICogb24gdGhlIHNlcnZlciB3aGVyZSB0aGVyZSBpcyBubyBzdGF0ZWZ1bCBVSS5cbiAqL1xuZnVuY3Rpb24gU3RhdGljUm91dGVyKHtcbiAgYmFzZW5hbWUsXG4gIGNoaWxkcmVuLFxuICBsb2NhdGlvbjogbG9jYXRpb25Qcm9wID0gXCIvXCJcbn0pIHtcbiAgaWYgKHR5cGVvZiBsb2NhdGlvblByb3AgPT09IFwic3RyaW5nXCIpIHtcbiAgICBsb2NhdGlvblByb3AgPSByZWFjdFJvdXRlckRvbS5wYXJzZVBhdGgobG9jYXRpb25Qcm9wKTtcbiAgfVxuICBsZXQgYWN0aW9uID0gcm91dGVyLkFjdGlvbi5Qb3A7XG4gIGxldCBsb2NhdGlvbiA9IHtcbiAgICBwYXRobmFtZTogbG9jYXRpb25Qcm9wLnBhdGhuYW1lIHx8IFwiL1wiLFxuICAgIHNlYXJjaDogbG9jYXRpb25Qcm9wLnNlYXJjaCB8fCBcIlwiLFxuICAgIGhhc2g6IGxvY2F0aW9uUHJvcC5oYXNoIHx8IFwiXCIsXG4gICAgc3RhdGU6IGxvY2F0aW9uUHJvcC5zdGF0ZSB8fCBudWxsLFxuICAgIGtleTogbG9jYXRpb25Qcm9wLmtleSB8fCBcImRlZmF1bHRcIlxuICB9O1xuICBsZXQgc3RhdGljTmF2aWdhdG9yID0gZ2V0U3RhdGVsZXNzTmF2aWdhdG9yKCk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KHJlYWN0Um91dGVyRG9tLlJvdXRlciwge1xuICAgIGJhc2VuYW1lOiBiYXNlbmFtZSxcbiAgICBjaGlsZHJlbjogY2hpbGRyZW4sXG4gICAgbG9jYXRpb246IGxvY2F0aW9uLFxuICAgIG5hdmlnYXRpb25UeXBlOiBhY3Rpb24sXG4gICAgbmF2aWdhdG9yOiBzdGF0aWNOYXZpZ2F0b3IsXG4gICAgc3RhdGljOiB0cnVlXG4gIH0pO1xufVxuLyoqXG4gKiBBIERhdGEgUm91dGVyIHRoYXQgbWF5IG5vdCBuYXZpZ2F0ZSB0byBhbnkgb3RoZXIgbG9jYXRpb24uIFRoaXMgaXMgdXNlZnVsXG4gKiBvbiB0aGUgc2VydmVyIHdoZXJlIHRoZXJlIGlzIG5vIHN0YXRlZnVsIFVJLlxuICovXG5mdW5jdGlvbiBTdGF0aWNSb3V0ZXJQcm92aWRlcih7XG4gIGNvbnRleHQsXG4gIHJvdXRlcjogcm91dGVyJDEsXG4gIGh5ZHJhdGUgPSB0cnVlLFxuICBub25jZVxufSkge1xuICAhKHJvdXRlciQxICYmIGNvbnRleHQpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gcm91dGVyLlVOU0FGRV9pbnZhcmlhbnQoZmFsc2UsIFwiWW91IG11c3QgcHJvdmlkZSBgcm91dGVyYCBhbmQgYGNvbnRleHRgIHRvIDxTdGF0aWNSb3V0ZXJQcm92aWRlcj5cIikgOiByb3V0ZXIuVU5TQUZFX2ludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gIGxldCBkYXRhUm91dGVyQ29udGV4dCA9IHtcbiAgICByb3V0ZXI6IHJvdXRlciQxLFxuICAgIG5hdmlnYXRvcjogZ2V0U3RhdGVsZXNzTmF2aWdhdG9yKCksXG4gICAgc3RhdGljOiB0cnVlLFxuICAgIHN0YXRpY0NvbnRleHQ6IGNvbnRleHQsXG4gICAgYmFzZW5hbWU6IGNvbnRleHQuYmFzZW5hbWUgfHwgXCIvXCJcbiAgfTtcbiAgbGV0IGZldGNoZXJzQ29udGV4dCA9IG5ldyBNYXAoKTtcbiAgbGV0IGh5ZHJhdGVTY3JpcHQgPSBcIlwiO1xuICBpZiAoaHlkcmF0ZSAhPT0gZmFsc2UpIHtcbiAgICBsZXQgZGF0YSA9IHtcbiAgICAgIGxvYWRlckRhdGE6IGNvbnRleHQubG9hZGVyRGF0YSxcbiAgICAgIGFjdGlvbkRhdGE6IGNvbnRleHQuYWN0aW9uRGF0YSxcbiAgICAgIGVycm9yczogc2VyaWFsaXplRXJyb3JzKGNvbnRleHQuZXJyb3JzKVxuICAgIH07XG4gICAgLy8gVXNlIEpTT04ucGFyc2UgaGVyZSBpbnN0ZWFkIG9mIGVtYmVkZGluZyBhIHJhdyBKUyBvYmplY3QgaGVyZSB0byBzcGVlZFxuICAgIC8vIHVwIHBhcnNpbmcgb24gdGhlIGNsaWVudC4gIER1YWwtc3RyaW5naWZ5IGlzIG5lZWRlZCB0byBlbnN1cmUgYWxsIHF1b3Rlc1xuICAgIC8vIGFyZSBwcm9wZXJseSBlc2NhcGVkIGluIHRoZSByZXN1bHRpbmcgc3RyaW5nLiAgU2VlOlxuICAgIC8vICAgaHR0cHM6Ly92OC5kZXYvYmxvZy9jb3N0LW9mLWphdmFzY3JpcHQtMjAxOSNqc29uXG4gICAgbGV0IGpzb24gPSBodG1sRXNjYXBlKEpTT04uc3RyaW5naWZ5KEpTT04uc3RyaW5naWZ5KGRhdGEpKSk7XG4gICAgaHlkcmF0ZVNjcmlwdCA9IGB3aW5kb3cuX19zdGF0aWNSb3V0ZXJIeWRyYXRpb25EYXRhID0gSlNPTi5wYXJzZSgke2pzb259KTtgO1xuICB9XG4gIGxldCB7XG4gICAgc3RhdGVcbiAgfSA9IGRhdGFSb3V0ZXJDb250ZXh0LnJvdXRlcjtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoUmVhY3RfX25hbWVzcGFjZS5GcmFnbWVudCwgbnVsbCwgLyojX19QVVJFX18qL1JlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChyZWFjdFJvdXRlckRvbS5VTlNBRkVfRGF0YVJvdXRlckNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogZGF0YVJvdXRlckNvbnRleHRcbiAgfSwgLyojX19QVVJFX18qL1JlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChyZWFjdFJvdXRlckRvbS5VTlNBRkVfRGF0YVJvdXRlclN0YXRlQ29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiBzdGF0ZVxuICB9LCAvKiNfX1BVUkVfXyovUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KHJlYWN0Um91dGVyRG9tLlVOU0FGRV9GZXRjaGVyc0NvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogZmV0Y2hlcnNDb250ZXh0XG4gIH0sIC8qI19fUFVSRV9fKi9SZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQocmVhY3RSb3V0ZXJEb20uVU5TQUZFX1ZpZXdUcmFuc2l0aW9uQ29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiB7XG4gICAgICBpc1RyYW5zaXRpb25pbmc6IGZhbHNlXG4gICAgfVxuICB9LCAvKiNfX1BVUkVfXyovUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KHJlYWN0Um91dGVyRG9tLlJvdXRlciwge1xuICAgIGJhc2VuYW1lOiBkYXRhUm91dGVyQ29udGV4dC5iYXNlbmFtZSxcbiAgICBsb2NhdGlvbjogc3RhdGUubG9jYXRpb24sXG4gICAgbmF2aWdhdGlvblR5cGU6IHN0YXRlLmhpc3RvcnlBY3Rpb24sXG4gICAgbmF2aWdhdG9yOiBkYXRhUm91dGVyQ29udGV4dC5uYXZpZ2F0b3IsXG4gICAgc3RhdGljOiBkYXRhUm91dGVyQ29udGV4dC5zdGF0aWNcbiAgfSwgLyojX19QVVJFX18qL1JlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChEYXRhUm91dGVzLCB7XG4gICAgcm91dGVzOiByb3V0ZXIkMS5yb3V0ZXMsXG4gICAgc3RhdGU6IHN0YXRlXG4gIH0pKSkpKSksIGh5ZHJhdGVTY3JpcHQgPyAvKiNfX1BVUkVfXyovUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIsIHtcbiAgICBzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmc6IHRydWUsXG4gICAgbm9uY2U6IG5vbmNlLFxuICAgIGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MOiB7XG4gICAgICBfX2h0bWw6IGh5ZHJhdGVTY3JpcHRcbiAgICB9XG4gIH0pIDogbnVsbCk7XG59XG5mdW5jdGlvbiBEYXRhUm91dGVzKHtcbiAgcm91dGVzLFxuICBzdGF0ZVxufSkge1xuICByZXR1cm4gcmVhY3RSb3V0ZXIuVU5TQUZFX3VzZVJvdXRlc0ltcGwocm91dGVzLCB1bmRlZmluZWQsIHN0YXRlKTtcbn1cbmZ1bmN0aW9uIHNlcmlhbGl6ZUVycm9ycyhlcnJvcnMpIHtcbiAgaWYgKCFlcnJvcnMpIHJldHVybiBudWxsO1xuICBsZXQgZW50cmllcyA9IE9iamVjdC5lbnRyaWVzKGVycm9ycyk7XG4gIGxldCBzZXJpYWxpemVkID0ge307XG4gIGZvciAobGV0IFtrZXksIHZhbF0gb2YgZW50cmllcykge1xuICAgIC8vIEhleSB5b3UhICBJZiB5b3UgY2hhbmdlIHRoaXMsIHBsZWFzZSBjaGFuZ2UgdGhlIGNvcnJlc3BvbmRpbmcgbG9naWMgaW5cbiAgICAvLyBkZXNlcmlhbGl6ZUVycm9ycyBpbiByZWFjdC1yb3V0ZXItZG9tL2luZGV4LnRzeCA6KVxuICAgIGlmIChyb3V0ZXIuaXNSb3V0ZUVycm9yUmVzcG9uc2UodmFsKSkge1xuICAgICAgc2VyaWFsaXplZFtrZXldID0ge1xuICAgICAgICAuLi52YWwsXG4gICAgICAgIF9fdHlwZTogXCJSb3V0ZUVycm9yUmVzcG9uc2VcIlxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKHZhbCBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAvLyBEbyBub3Qgc2VyaWFsaXplIHN0YWNrIHRyYWNlcyBmcm9tIFNTUiBmb3Igc2VjdXJpdHkgcmVhc29uc1xuICAgICAgc2VyaWFsaXplZFtrZXldID0ge1xuICAgICAgICBtZXNzYWdlOiB2YWwubWVzc2FnZSxcbiAgICAgICAgX190eXBlOiBcIkVycm9yXCIsXG4gICAgICAgIC8vIElmIHRoaXMgaXMgYSBzdWJjbGFzcyAoaS5lLiwgUmVmZXJlbmNlRXJyb3IpLCBzZW5kIHVwIHRoZSB0eXBlIHNvIHdlXG4gICAgICAgIC8vIGNhbiByZS1jcmVhdGUgdGhlIHNhbWUgdHlwZSBkdXJpbmcgaHlkcmF0aW9uLlxuICAgICAgICAuLi4odmFsLm5hbWUgIT09IFwiRXJyb3JcIiA/IHtcbiAgICAgICAgICBfX3N1YlR5cGU6IHZhbC5uYW1lXG4gICAgICAgIH0gOiB7fSlcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHNlcmlhbGl6ZWRba2V5XSA9IHZhbDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHNlcmlhbGl6ZWQ7XG59XG5mdW5jdGlvbiBnZXRTdGF0ZWxlc3NOYXZpZ2F0b3IoKSB7XG4gIHJldHVybiB7XG4gICAgY3JlYXRlSHJlZixcbiAgICBlbmNvZGVMb2NhdGlvbixcbiAgICBwdXNoKHRvKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFlvdSBjYW5ub3QgdXNlIG5hdmlnYXRvci5wdXNoKCkgb24gdGhlIHNlcnZlciBiZWNhdXNlIGl0IGlzIGEgc3RhdGVsZXNzIGAgKyBgZW52aXJvbm1lbnQuIFRoaXMgZXJyb3Igd2FzIHByb2JhYmx5IHRyaWdnZXJlZCB3aGVuIHlvdSBkaWQgYSBgICsgYFxcYG5hdmlnYXRlKCR7SlNPTi5zdHJpbmdpZnkodG8pfSlcXGAgc29tZXdoZXJlIGluIHlvdXIgYXBwLmApO1xuICAgIH0sXG4gICAgcmVwbGFjZSh0bykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBZb3UgY2Fubm90IHVzZSBuYXZpZ2F0b3IucmVwbGFjZSgpIG9uIHRoZSBzZXJ2ZXIgYmVjYXVzZSBpdCBpcyBhIHN0YXRlbGVzcyBgICsgYGVudmlyb25tZW50LiBUaGlzIGVycm9yIHdhcyBwcm9iYWJseSB0cmlnZ2VyZWQgd2hlbiB5b3UgZGlkIGEgYCArIGBcXGBuYXZpZ2F0ZSgke0pTT04uc3RyaW5naWZ5KHRvKX0sIHsgcmVwbGFjZTogdHJ1ZSB9KVxcYCBzb21ld2hlcmUgYCArIGBpbiB5b3VyIGFwcC5gKTtcbiAgICB9LFxuICAgIGdvKGRlbHRhKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFlvdSBjYW5ub3QgdXNlIG5hdmlnYXRvci5nbygpIG9uIHRoZSBzZXJ2ZXIgYmVjYXVzZSBpdCBpcyBhIHN0YXRlbGVzcyBgICsgYGVudmlyb25tZW50LiBUaGlzIGVycm9yIHdhcyBwcm9iYWJseSB0cmlnZ2VyZWQgd2hlbiB5b3UgZGlkIGEgYCArIGBcXGBuYXZpZ2F0ZSgke2RlbHRhfSlcXGAgc29tZXdoZXJlIGluIHlvdXIgYXBwLmApO1xuICAgIH0sXG4gICAgYmFjaygpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgWW91IGNhbm5vdCB1c2UgbmF2aWdhdG9yLmJhY2soKSBvbiB0aGUgc2VydmVyIGJlY2F1c2UgaXQgaXMgYSBzdGF0ZWxlc3MgYCArIGBlbnZpcm9ubWVudC5gKTtcbiAgICB9LFxuICAgIGZvcndhcmQoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFlvdSBjYW5ub3QgdXNlIG5hdmlnYXRvci5mb3J3YXJkKCkgb24gdGhlIHNlcnZlciBiZWNhdXNlIGl0IGlzIGEgc3RhdGVsZXNzIGAgKyBgZW52aXJvbm1lbnQuYCk7XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlU3RhdGljSGFuZGxlcihyb3V0ZXMsIG9wdHMpIHtcbiAgcmV0dXJuIHJvdXRlci5jcmVhdGVTdGF0aWNIYW5kbGVyKHJvdXRlcywge1xuICAgIC4uLm9wdHMsXG4gICAgbWFwUm91dGVQcm9wZXJ0aWVzOiByZWFjdFJvdXRlci5VTlNBRkVfbWFwUm91dGVQcm9wZXJ0aWVzXG4gIH0pO1xufVxuZnVuY3Rpb24gY3JlYXRlU3RhdGljUm91dGVyKHJvdXRlcywgY29udGV4dCkge1xuICBsZXQgbWFuaWZlc3QgPSB7fTtcbiAgbGV0IGRhdGFSb3V0ZXMgPSByb3V0ZXIuVU5TQUZFX2NvbnZlcnRSb3V0ZXNUb0RhdGFSb3V0ZXMocm91dGVzLCByZWFjdFJvdXRlci5VTlNBRkVfbWFwUm91dGVQcm9wZXJ0aWVzLCB1bmRlZmluZWQsIG1hbmlmZXN0KTtcbiAgLy8gQmVjYXVzZSBvdXIgY29udGV4dCBtYXRjaGVzIG1heSBiZSBmcm9tIGEgZnJhbWV3b3JrLWFnbm9zdGljIHNldCBvZlxuICAvLyByb3V0ZXMgcGFzc2VkIHRvIGNyZWF0ZVN0YXRpY0hhbmRsZXIoKSwgd2UgdXBkYXRlIHRoZW0gaGVyZSB3aXRoIG91clxuICAvLyBuZXdseSBjcmVhdGVkL2VuaGFuY2VkIGRhdGEgcm91dGVzXG4gIGxldCBtYXRjaGVzID0gY29udGV4dC5tYXRjaGVzLm1hcChtYXRjaCA9PiB7XG4gICAgbGV0IHJvdXRlID0gbWFuaWZlc3RbbWF0Y2gucm91dGUuaWRdIHx8IG1hdGNoLnJvdXRlO1xuICAgIHJldHVybiB7XG4gICAgICAuLi5tYXRjaCxcbiAgICAgIHJvdXRlXG4gICAgfTtcbiAgfSk7XG4gIGxldCBtc2cgPSBtZXRob2QgPT4gYFlvdSBjYW5ub3QgdXNlIHJvdXRlci4ke21ldGhvZH0oKSBvbiB0aGUgc2VydmVyIGJlY2F1c2UgaXQgaXMgYSBzdGF0ZWxlc3MgZW52aXJvbm1lbnRgO1xuICByZXR1cm4ge1xuICAgIGdldCBiYXNlbmFtZSgpIHtcbiAgICAgIHJldHVybiBjb250ZXh0LmJhc2VuYW1lO1xuICAgIH0sXG4gICAgZ2V0IHN0YXRlKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaGlzdG9yeUFjdGlvbjogcm91dGVyLkFjdGlvbi5Qb3AsXG4gICAgICAgIGxvY2F0aW9uOiBjb250ZXh0LmxvY2F0aW9uLFxuICAgICAgICBtYXRjaGVzLFxuICAgICAgICBsb2FkZXJEYXRhOiBjb250ZXh0LmxvYWRlckRhdGEsXG4gICAgICAgIGFjdGlvbkRhdGE6IGNvbnRleHQuYWN0aW9uRGF0YSxcbiAgICAgICAgZXJyb3JzOiBjb250ZXh0LmVycm9ycyxcbiAgICAgICAgaW5pdGlhbGl6ZWQ6IHRydWUsXG4gICAgICAgIG5hdmlnYXRpb246IHJvdXRlci5JRExFX05BVklHQVRJT04sXG4gICAgICAgIHJlc3RvcmVTY3JvbGxQb3NpdGlvbjogbnVsbCxcbiAgICAgICAgcHJldmVudFNjcm9sbFJlc2V0OiBmYWxzZSxcbiAgICAgICAgcmV2YWxpZGF0aW9uOiBcImlkbGVcIixcbiAgICAgICAgZmV0Y2hlcnM6IG5ldyBNYXAoKSxcbiAgICAgICAgYmxvY2tlcnM6IG5ldyBNYXAoKVxuICAgICAgfTtcbiAgICB9LFxuICAgIGdldCByb3V0ZXMoKSB7XG4gICAgICByZXR1cm4gZGF0YVJvdXRlcztcbiAgICB9LFxuICAgIGdldCB3aW5kb3coKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH0sXG4gICAgaW5pdGlhbGl6ZSgpIHtcbiAgICAgIHRocm93IG1zZyhcImluaXRpYWxpemVcIik7XG4gICAgfSxcbiAgICBzdWJzY3JpYmUoKSB7XG4gICAgICB0aHJvdyBtc2coXCJzdWJzY3JpYmVcIik7XG4gICAgfSxcbiAgICBlbmFibGVTY3JvbGxSZXN0b3JhdGlvbigpIHtcbiAgICAgIHRocm93IG1zZyhcImVuYWJsZVNjcm9sbFJlc3RvcmF0aW9uXCIpO1xuICAgIH0sXG4gICAgbmF2aWdhdGUoKSB7XG4gICAgICB0aHJvdyBtc2coXCJuYXZpZ2F0ZVwiKTtcbiAgICB9LFxuICAgIGZldGNoKCkge1xuICAgICAgdGhyb3cgbXNnKFwiZmV0Y2hcIik7XG4gICAgfSxcbiAgICByZXZhbGlkYXRlKCkge1xuICAgICAgdGhyb3cgbXNnKFwicmV2YWxpZGF0ZVwiKTtcbiAgICB9LFxuICAgIGNyZWF0ZUhyZWYsXG4gICAgZW5jb2RlTG9jYXRpb24sXG4gICAgZ2V0RmV0Y2hlcigpIHtcbiAgICAgIHJldHVybiByb3V0ZXIuSURMRV9GRVRDSEVSO1xuICAgIH0sXG4gICAgZGVsZXRlRmV0Y2hlcigpIHtcbiAgICAgIHRocm93IG1zZyhcImRlbGV0ZUZldGNoZXJcIik7XG4gICAgfSxcbiAgICBkaXNwb3NlKCkge1xuICAgICAgdGhyb3cgbXNnKFwiZGlzcG9zZVwiKTtcbiAgICB9LFxuICAgIGdldEJsb2NrZXIoKSB7XG4gICAgICByZXR1cm4gcm91dGVyLklETEVfQkxPQ0tFUjtcbiAgICB9LFxuICAgIGRlbGV0ZUJsb2NrZXIoKSB7XG4gICAgICB0aHJvdyBtc2coXCJkZWxldGVCbG9ja2VyXCIpO1xuICAgIH0sXG4gICAgX2ludGVybmFsRmV0Y2hDb250cm9sbGVyczogbmV3IE1hcCgpLFxuICAgIF9pbnRlcm5hbEFjdGl2ZURlZmVycmVkczogbmV3IE1hcCgpLFxuICAgIF9pbnRlcm5hbFNldFJvdXRlcygpIHtcbiAgICAgIHRocm93IG1zZyhcIl9pbnRlcm5hbFNldFJvdXRlc1wiKTtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVIcmVmKHRvKSB7XG4gIHJldHVybiB0eXBlb2YgdG8gPT09IFwic3RyaW5nXCIgPyB0byA6IHJlYWN0Um91dGVyRG9tLmNyZWF0ZVBhdGgodG8pO1xufVxuZnVuY3Rpb24gZW5jb2RlTG9jYXRpb24odG8pIHtcbiAgbGV0IGhyZWYgPSB0eXBlb2YgdG8gPT09IFwic3RyaW5nXCIgPyB0byA6IHJlYWN0Um91dGVyRG9tLmNyZWF0ZVBhdGgodG8pO1xuICBsZXQgZW5jb2RlZCA9IEFCU09MVVRFX1VSTF9SRUdFWC50ZXN0KGhyZWYpID8gbmV3IFVSTChocmVmKSA6IG5ldyBVUkwoaHJlZiwgXCJodHRwOi8vbG9jYWxob3N0XCIpO1xuICByZXR1cm4ge1xuICAgIHBhdGhuYW1lOiBlbmNvZGVkLnBhdGhuYW1lLFxuICAgIHNlYXJjaDogZW5jb2RlZC5zZWFyY2gsXG4gICAgaGFzaDogZW5jb2RlZC5oYXNoXG4gIH07XG59XG5jb25zdCBBQlNPTFVURV9VUkxfUkVHRVggPSAvXig/OlthLXpdW2EtejAtOSsuLV0qOnxcXC9cXC8pL2k7XG4vLyBUaGlzIHV0aWxpdHkgaXMgYmFzZWQgb24gaHR0cHM6Ly9naXRodWIuY29tL3plcnRvc2gvaHRtbGVzY2FwZVxuLy8gTGljZW5zZTogaHR0cHM6Ly9naXRodWIuY29tL3plcnRvc2gvaHRtbGVzY2FwZS9ibG9iLzA1MjdjYTcxNTZhNTI0ZDI1NjEwMWJiMzEwYTlmOTcwZjYzMDc4YWQvTElDRU5TRVxuY29uc3QgRVNDQVBFX0xPT0tVUCA9IHtcbiAgXCImXCI6IFwiXFxcXHUwMDI2XCIsXG4gIFwiPlwiOiBcIlxcXFx1MDAzZVwiLFxuICBcIjxcIjogXCJcXFxcdTAwM2NcIixcbiAgXCJcXHUyMDI4XCI6IFwiXFxcXHUyMDI4XCIsXG4gIFwiXFx1MjAyOVwiOiBcIlxcXFx1MjAyOVwiXG59O1xuY29uc3QgRVNDQVBFX1JFR0VYID0gL1smPjxcXHUyMDI4XFx1MjAyOV0vZztcbmZ1bmN0aW9uIGh0bWxFc2NhcGUoc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZShFU0NBUEVfUkVHRVgsIG1hdGNoID0+IEVTQ0FQRV9MT09LVVBbbWF0Y2hdKTtcbn1cblxuZXhwb3J0cy5TdGF0aWNSb3V0ZXIgPSBTdGF0aWNSb3V0ZXI7XG5leHBvcnRzLlN0YXRpY1JvdXRlclByb3ZpZGVyID0gU3RhdGljUm91dGVyUHJvdmlkZXI7XG5leHBvcnRzLmNyZWF0ZVN0YXRpY0hhbmRsZXIgPSBjcmVhdGVTdGF0aWNIYW5kbGVyO1xuZXhwb3J0cy5jcmVhdGVTdGF0aWNSb3V0ZXIgPSBjcmVhdGVTdGF0aWNSb3V0ZXI7XG4iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJSZWFjdCIsInJlcXVpcmUiLCJyb3V0ZXIiLCJyZWFjdFJvdXRlciIsInJlYWN0Um91dGVyRG9tIiwiX2ludGVyb3BOYW1lc3BhY2UiLCJlIiwiX19lc01vZHVsZSIsIm4iLCJjcmVhdGUiLCJrZXlzIiwiZm9yRWFjaCIsImsiLCJkIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiZ2V0IiwiZW51bWVyYWJsZSIsImZyZWV6ZSIsIlJlYWN0X19uYW1lc3BhY2UiLCJTdGF0aWNSb3V0ZXIiLCJiYXNlbmFtZSIsImNoaWxkcmVuIiwibG9jYXRpb24iLCJsb2NhdGlvblByb3AiLCJwYXJzZVBhdGgiLCJhY3Rpb24iLCJBY3Rpb24iLCJQb3AiLCJwYXRobmFtZSIsInNlYXJjaCIsImhhc2giLCJzdGF0ZSIsImtleSIsInN0YXRpY05hdmlnYXRvciIsImdldFN0YXRlbGVzc05hdmlnYXRvciIsImNyZWF0ZUVsZW1lbnQiLCJSb3V0ZXIiLCJuYXZpZ2F0aW9uVHlwZSIsIm5hdmlnYXRvciIsInN0YXRpYyIsIlN0YXRpY1JvdXRlclByb3ZpZGVyIiwiY29udGV4dCIsInJvdXRlciQxIiwiaHlkcmF0ZSIsIm5vbmNlIiwicHJvY2VzcyIsIlVOU0FGRV9pbnZhcmlhbnQiLCJkYXRhUm91dGVyQ29udGV4dCIsInN0YXRpY0NvbnRleHQiLCJmZXRjaGVyc0NvbnRleHQiLCJNYXAiLCJoeWRyYXRlU2NyaXB0IiwiZGF0YSIsImxvYWRlckRhdGEiLCJhY3Rpb25EYXRhIiwiZXJyb3JzIiwic2VyaWFsaXplRXJyb3JzIiwianNvbiIsImh0bWxFc2NhcGUiLCJKU09OIiwic3RyaW5naWZ5IiwiRnJhZ21lbnQiLCJVTlNBRkVfRGF0YVJvdXRlckNvbnRleHQiLCJQcm92aWRlciIsIlVOU0FGRV9EYXRhUm91dGVyU3RhdGVDb250ZXh0IiwiVU5TQUZFX0ZldGNoZXJzQ29udGV4dCIsIlVOU0FGRV9WaWV3VHJhbnNpdGlvbkNvbnRleHQiLCJpc1RyYW5zaXRpb25pbmciLCJoaXN0b3J5QWN0aW9uIiwiRGF0YVJvdXRlcyIsInJvdXRlcyIsInN1cHByZXNzSHlkcmF0aW9uV2FybmluZyIsImRhbmdlcm91c2x5U2V0SW5uZXJIVE1MIiwiX19odG1sIiwiVU5TQUZFX3VzZVJvdXRlc0ltcGwiLCJ1bmRlZmluZWQiLCJlbnRyaWVzIiwic2VyaWFsaXplZCIsInZhbCIsImlzUm91dGVFcnJvclJlc3BvbnNlIiwiX190eXBlIiwiRXJyb3IiLCJtZXNzYWdlIiwibmFtZSIsIl9fc3ViVHlwZSIsImNyZWF0ZUhyZWYiLCJlbmNvZGVMb2NhdGlvbiIsInB1c2giLCJ0byIsInJlcGxhY2UiLCJnbyIsImRlbHRhIiwiYmFjayIsImZvcndhcmQiLCJjcmVhdGVTdGF0aWNIYW5kbGVyIiwib3B0cyIsIm1hcFJvdXRlUHJvcGVydGllcyIsIlVOU0FGRV9tYXBSb3V0ZVByb3BlcnRpZXMiLCJjcmVhdGVTdGF0aWNSb3V0ZXIiLCJtYW5pZmVzdCIsImRhdGFSb3V0ZXMiLCJVTlNBRkVfY29udmVydFJvdXRlc1RvRGF0YVJvdXRlcyIsIm1hdGNoZXMiLCJtYXAiLCJtYXRjaCIsInJvdXRlIiwiaWQiLCJtc2ciLCJtZXRob2QiLCJpbml0aWFsaXplZCIsIm5hdmlnYXRpb24iLCJJRExFX05BVklHQVRJT04iLCJyZXN0b3JlU2Nyb2xsUG9zaXRpb24iLCJwcmV2ZW50U2Nyb2xsUmVzZXQiLCJyZXZhbGlkYXRpb24iLCJmZXRjaGVycyIsImJsb2NrZXJzIiwid2luZG93IiwiaW5pdGlhbGl6ZSIsInN1YnNjcmliZSIsImVuYWJsZVNjcm9sbFJlc3RvcmF0aW9uIiwibmF2aWdhdGUiLCJmZXRjaCIsInJldmFsaWRhdGUiLCJnZXRGZXRjaGVyIiwiSURMRV9GRVRDSEVSIiwiZGVsZXRlRmV0Y2hlciIsImRpc3Bvc2UiLCJnZXRCbG9ja2VyIiwiSURMRV9CTE9DS0VSIiwiZGVsZXRlQmxvY2tlciIsIl9pbnRlcm5hbEZldGNoQ29udHJvbGxlcnMiLCJfaW50ZXJuYWxBY3RpdmVEZWZlcnJlZHMiLCJfaW50ZXJuYWxTZXRSb3V0ZXMiLCJjcmVhdGVQYXRoIiwiaHJlZiIsImVuY29kZWQiLCJBQlNPTFVURV9VUkxfUkVHRVgiLCJ0ZXN0IiwiVVJMIiwiRVNDQVBFX0xPT0tVUCIsIkVTQ0FQRV9SRUdFWCIsInN0ciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-router-dom/server.js\n");

/***/ })

};
;